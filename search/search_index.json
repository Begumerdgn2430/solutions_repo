{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 . \ud83c\udfaf Investigating the Range as a Function of the Angle of Projection Derivation of the General Solution from the Laws of Motion We begin with Newton's Second Law of Motion: \\[ \\vec{F} = m \\vec{a} \\] This implies that the net force acting on a body is equal to the mass of the body multiplied by its acceleration. 1. Motion in One Dimension Consider motion along the x-axis with constant acceleration \\(a\\) . From the definition of acceleration: \\[ a = \\frac{dv}{dt} \\] Integrating both sides with respect to time: \\[ \\int a \\, dt = \\int \\frac{dv}{dt} \\, dt \\Rightarrow at + C_1 = v(t) \\] Letting \\(v_0\\) be the initial velocity at \\(t = 0\\) , we find \\(C_1 = v_0\\) , so: \\[ v(t) = v_0 + at \\] Now, velocity is the derivative of position: \\[ v = \\frac{dx}{dt} \\] Integrating again: \\[ \\int v \\, dt = \\int (v_0 + at) \\, dt = v_0 t + \\frac{1}{2} a t^2 + C_2 \\] Letting \\(x_0\\) be the initial position at \\(t = 0\\) , we find \\(C_2 = x_0\\) , giving the position function: \\[ x(t) = x_0 + v_0 t + \\frac{1}{2} a t^2 \\] 2. General Solution in Two Dimensions We now extend the solution to two-dimensional motion with constant acceleration. Let \\(\\vec{r}(t) = (x(t), y(t))\\) , \\(\\vec{v}(t) = (v_x(t), v_y(t))\\) , and \\(\\vec{a} = (a_x, a_y)\\) . Using the same integration steps for each component: Velocity components: \\[ v_x(t) = v_{0x} + a_x t \\] \\[ v_y(t) = v_{0y} + a_y t \\] Position components: \\[ x(t) = x_0 + v_{0x} t + \\frac{1}{2} a_x t^2 \\] \\[ y(t) = y_0 + v_{0y} t + \\frac{1}{2} a_y t^2 \\] Thus, the general vector solution is: \\[ \\vec{r}(t) = \\vec{r}_0 + \\vec{v}_0 t + \\frac{1}{2} \\vec{a} t^2 \\] where: \\(\\vec{r}_0 = (x_0, y_0)\\) is the initial position, \\(\\vec{v}_0 = (v_{0x}, v_{0y})\\) is the initial velocity, \\(\\vec{a} = (a_x, a_y)\\) is the constant acceleration. This equation describes the position of a particle under constant acceleration in two-dimensional space. 2. Theoretical Foundation \ud83e\uddee Velocity Components: Horizontal: \\(v_{0x} = v_0 \\cos(\\theta)\\) Vertical: \\(v_{0y} = v_0 \\sin(\\theta)\\) \u23f1\ufe0f Time of Flight: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] \ud83d\udccf Range: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum range occurs at \\(\\theta = 45^\\circ\\) Doubling \\(v_0\\) quadruples the range 3. Graphical Analysis \ud83d\udcca Plot 1: Range vs Angle for Different Velocities This graph shows how the range changes with angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . All curves peak at \\(45^\\circ\\) , confirming it as the optimal launch angle. \ud83d\udcca Plot 2: Range vs Angle on Different Planets Here, \\(v_0 = 20 \\, \\text{m/s}\\) and we compare projectile ranges on Earth , Moon , and Mars . The lower the gravity, the longer the projectile stays in the air, resulting in greater range. \ud83d\udcca Plot 3: Trajectories from Different Initial Heights This graph uses a fixed angle ( \\(\\theta = 45^\\circ\\) ) and velocity ( \\(v_0 = 20\\, \\text{m/s}\\) ), but launches the projectile from various heights ( \\(h = 0, 5, 10\\, \\text{m}\\) ). As expected, higher launch points result in longer range and higher peak. \ud83d\udcca Plot 4: Trajectories at Multiple Angles Here we show the paths of projectiles launched at the same speed ( \\(v_0 = 20\\, \\text{m/s}\\) ) but with different angles: \\(15^\\circ\\) , \\(39^\\circ\\) , \\(45^\\circ\\) , \\(60^\\circ\\) , and \\(75^\\circ\\) . It visually demonstrates how lower angles have flatter paths and shorter airtime. \ud83d\udcca Plot 5: With vs Without Air Resistance This comparison plot shows the difference in trajectories when air resistance is considered. While real drag modeling is complex, we simulate a simplified scenario showing that air resistance reduces both range and peak height. 4. Insights and Applications 45\u00b0 is the optimal angle for range under ideal (no air) conditions. Air resistance significantly shortens the range and reduces height. Different planets yield different results due to varying gravity. Initial height adds more airtime and therefore greater range. These concepts are important in: - Sports physics (kicking, throwing) - Military ballistics - Spacecraft launches - Engineering simulations 5. Conclusion With physics equations and computational tools, we effectively analyzed how a projectile behaves under various scenarios. Graphical analysis helped confirm theoretical expectations and made the results more intuitive. Simulate It with Python Here\u2019s some Python code that calculates the range for different angles and plots import numpy as np import matplotlib.pyplot as plt # Gravity and initial speed g = 9.81 # m/s^2 v0 = 20.0 # m/s # Try angles from 0 to 90 degrees angles_deg = np.linspace(0, 90, 100) angles_rad = np.radians(angles_deg) # Calculate the range for each angle ranges = (v0 ** 2) * np.sin(2 * angles_rad) / g # Plot it plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges) plt.title(\"How Far Does It Go? Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.axvline(x=45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.legend() plt.tight_layout() plt.show() Final The sweet spot for distance is 45\u00b0\u2014that\u2019s when the projectile goes the farthest. The graph is symmetric: launching at 30\u00b0 gives you the same range as 60\u00b0. If you increase the launch speed, the range increases a lot (since it\u2019s based on \\(v_0^2\\) ).","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":".","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83c\udfaf Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-the-general-solution-from-the-laws-of-motion","text":"We begin with Newton's Second Law of Motion: \\[ \\vec{F} = m \\vec{a} \\] This implies that the net force acting on a body is equal to the mass of the body multiplied by its acceleration.","title":"Derivation of the General Solution from the Laws of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motion-in-one-dimension","text":"Consider motion along the x-axis with constant acceleration \\(a\\) . From the definition of acceleration: \\[ a = \\frac{dv}{dt} \\] Integrating both sides with respect to time: \\[ \\int a \\, dt = \\int \\frac{dv}{dt} \\, dt \\Rightarrow at + C_1 = v(t) \\] Letting \\(v_0\\) be the initial velocity at \\(t = 0\\) , we find \\(C_1 = v_0\\) , so: \\[ v(t) = v_0 + at \\] Now, velocity is the derivative of position: \\[ v = \\frac{dx}{dt} \\] Integrating again: \\[ \\int v \\, dt = \\int (v_0 + at) \\, dt = v_0 t + \\frac{1}{2} a t^2 + C_2 \\] Letting \\(x_0\\) be the initial position at \\(t = 0\\) , we find \\(C_2 = x_0\\) , giving the position function: \\[ x(t) = x_0 + v_0 t + \\frac{1}{2} a t^2 \\]","title":"1. Motion in One Dimension"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-general-solution-in-two-dimensions","text":"We now extend the solution to two-dimensional motion with constant acceleration. Let \\(\\vec{r}(t) = (x(t), y(t))\\) , \\(\\vec{v}(t) = (v_x(t), v_y(t))\\) , and \\(\\vec{a} = (a_x, a_y)\\) . Using the same integration steps for each component:","title":"2. General Solution in Two Dimensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#velocity-components","text":"\\[ v_x(t) = v_{0x} + a_x t \\] \\[ v_y(t) = v_{0y} + a_y t \\]","title":"Velocity components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#position-components","text":"\\[ x(t) = x_0 + v_{0x} t + \\frac{1}{2} a_x t^2 \\] \\[ y(t) = y_0 + v_{0y} t + \\frac{1}{2} a_y t^2 \\] Thus, the general vector solution is: \\[ \\vec{r}(t) = \\vec{r}_0 + \\vec{v}_0 t + \\frac{1}{2} \\vec{a} t^2 \\] where: \\(\\vec{r}_0 = (x_0, y_0)\\) is the initial position, \\(\\vec{v}_0 = (v_{0x}, v_{0y})\\) is the initial velocity, \\(\\vec{a} = (a_x, a_y)\\) is the constant acceleration. This equation describes the position of a particle under constant acceleration in two-dimensional space.","title":"Position components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#velocity-components_1","text":"Horizontal: \\(v_{0x} = v_0 \\cos(\\theta)\\) Vertical: \\(v_{0y} = v_0 \\sin(\\theta)\\)","title":"\ud83e\uddee Velocity Components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"\\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"\u23f1\ufe0f Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"\\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum range occurs at \\(\\theta = 45^\\circ\\) Doubling \\(v_0\\) quadruples the range","title":"\ud83d\udccf Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-graphical-analysis","text":"","title":"3. Graphical Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-1-range-vs-angle-for-different-velocities","text":"This graph shows how the range changes with angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . All curves peak at \\(45^\\circ\\) , confirming it as the optimal launch angle.","title":"\ud83d\udcca Plot 1: Range vs Angle for Different Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-2-range-vs-angle-on-different-planets","text":"Here, \\(v_0 = 20 \\, \\text{m/s}\\) and we compare projectile ranges on Earth , Moon , and Mars . The lower the gravity, the longer the projectile stays in the air, resulting in greater range.","title":"\ud83d\udcca Plot 2: Range vs Angle on Different Planets"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-3-trajectories-from-different-initial-heights","text":"This graph uses a fixed angle ( \\(\\theta = 45^\\circ\\) ) and velocity ( \\(v_0 = 20\\, \\text{m/s}\\) ), but launches the projectile from various heights ( \\(h = 0, 5, 10\\, \\text{m}\\) ). As expected, higher launch points result in longer range and higher peak.","title":"\ud83d\udcca Plot 3: Trajectories from Different Initial Heights"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-4-trajectories-at-multiple-angles","text":"Here we show the paths of projectiles launched at the same speed ( \\(v_0 = 20\\, \\text{m/s}\\) ) but with different angles: \\(15^\\circ\\) , \\(39^\\circ\\) , \\(45^\\circ\\) , \\(60^\\circ\\) , and \\(75^\\circ\\) . It visually demonstrates how lower angles have flatter paths and shorter airtime.","title":"\ud83d\udcca Plot 4: Trajectories at Multiple Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-5-with-vs-without-air-resistance","text":"This comparison plot shows the difference in trajectories when air resistance is considered. While real drag modeling is complex, we simulate a simplified scenario showing that air resistance reduces both range and peak height.","title":"\ud83d\udcca Plot 5: With vs Without Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-insights-and-applications","text":"45\u00b0 is the optimal angle for range under ideal (no air) conditions. Air resistance significantly shortens the range and reduces height. Different planets yield different results due to varying gravity. Initial height adds more airtime and therefore greater range. These concepts are important in: - Sports physics (kicking, throwing) - Military ballistics - Spacecraft launches - Engineering simulations","title":"4. Insights and Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-conclusion","text":"With physics equations and computational tools, we effectively analyzed how a projectile behaves under various scenarios. Graphical analysis helped confirm theoretical expectations and made the results more intuitive.","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulate-it-with-python","text":"Here\u2019s some Python code that calculates the range for different angles and plots import numpy as np import matplotlib.pyplot as plt # Gravity and initial speed g = 9.81 # m/s^2 v0 = 20.0 # m/s # Try angles from 0 to 90 degrees angles_deg = np.linspace(0, 90, 100) angles_rad = np.radians(angles_deg) # Calculate the range for each angle ranges = (v0 ** 2) * np.sin(2 * angles_rad) / g # Plot it plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges) plt.title(\"How Far Does It Go? Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.axvline(x=45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.legend() plt.tight_layout() plt.show()","title":"Simulate It with Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#final","text":"The sweet spot for distance is 45\u00b0\u2014that\u2019s when the projectile goes the farthest. The graph is symmetric: launching at 30\u00b0 gives you the same range as 60\u00b0. If you increase the launch speed, the range increases a lot (since it\u2019s based on \\(v_0^2\\) ).","title":"Final"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Pendulum in physcics is a classic example of a system that exhibits periodic motion. A pendulum consists of a mass (the bob) attached to a string or rod that swings back and forth under the influence of gravity. The motion of the pendulum can be described by its period, which is the time it takes to complete one full swing, and its amplitude, which is the maximum distance from the equilibrium position. Colab Colab Link Pendulum Example import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of differential equations def pendulum_ode(t, y, b, g, L, A, omega): theta, omega_angular = y dydt = [omega_angular, A * np.cos(omega * t) - b * omega_angular - (g / L) * np.sin(theta)] return dydt # Set parameters (you can change these) g = 9.81 # acceleration due to gravity L = 1.0 # length of the pendulum t_span = [0, 20] # time span for simulation t_eval = np.linspace(t_span[0], t_span[1], 500) # points to evaluate the solution # Initial conditions (angle, angular velocity) initial_conditions = [np.pi / 4, 0] # Start at 45 degrees with zero initial velocity # Pure pendulum (b=0, A=0) b_pure = 0 A_pure = 0 omega_pure = 0 sol_pure = solve_ivp(pendulum_ode, t_span, initial_conditions, t_eval=t_eval, args=(b_pure, g, L, A_pure, omega_pure)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_pure.t, sol_pure.y[0]) plt.xlabel(\"Time (t)\") plt.ylabel(\"Angle (radians)\") plt.title(\"Angle vs Time (Pure Pendulum)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_pure.y[0], sol_pure.y[1]) plt.xlabel(\"Angle (radians)\") plt.ylabel(\"Angular Velocity (radians/s)\") plt.title(\"Phase Diagram (Pure Pendulum)\") plt.grid(True) plt.tight_layout() plt.show() Scenario 1: Pure Pendulum (b=0, A=0) This scenario represents the simplest case of a pendulum, where there is no damping (the resistance to motion due to friction or air resistance is zero, b=0 ) and no external force acting on the system ( A=0 ). The motion is purely governed by gravity. We expect to see simple harmonic motion (or close to it for small angles) with a constant amplitude and period. The phase diagram should show a closed elliptical path. Scenario 2: Pendulum with Damping (b > 0, A=0) In this scenario, we introduce damping to the pendulum ( b > 0 ), while still having no external force ( A=0 ). Damping causes the pendulum to lose energy over time, and its oscillations will gradually decrease in amplitude until it comes to rest at the equilibrium position (hanging straight down). The phase diagram should show a spiral path that converges towards the origin (0,0), representing the decrease in both angle and angular velocity. Scenario 3: Pendulum with External Force (b=0, A > 0) Here, we examine a pendulum with an external periodic force applied ( A > 0 ), but without any damping ( b=0 ). The external force continuously adds energy to the system. Depending on the frequency of the external force ( omega ), the pendulum's motion can become quite complex and may not settle into a stable oscillation. The phase diagram may show irregular or complex patterns, not necessarily closed loops or simple spirals. Scenario 4: Forced Damped Pendulum (Less Chaotic) This scenario combines both damping ( b > 0 ) and an external force ( A > 0 ). With moderate damping, the system tends to reach a steady state where the energy added by the external force is balanced by the energy dissipated by damping. The motion is typically oscillatory and predictable, though the exact pattern depends on the parameters. The phase diagram might show a limit cycle, which is a stable, closed trajectory that the system settles into after an initial transient period. import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt # Define the pendulum equation def pendulum(y, t, b, g, l, A, omega): theta, omega_dot = y dydt = [omega_dot, -b * omega_dot - (g / l) * np.sin(theta) + A * np.cos(omega * t)] return dydt # --- Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance) --- b = 0.1 A = 1.2 omega = 0.95 # Near resonance # --- Common Parameters --- g = 9.81 # acceleration due to gravity l = 1.0 # length of the pendulum y0 = [np.pi / 4, 0.0] # initial conditions (angle, angular velocity) t = np.linspace(0, 100, 1001) # time points (extended for chaos) # Solve the differential equation sol = odeint(pendulum, y0, t, args=(b, g, l, A, omega)) angle = sol[:, 0] angular_velocity = sol[:, 1] # Plot Angle vs. Time plt.figure(figsize=(10, 4)) plt.plot(t, angle) plt.xlabel('Time') plt.ylabel('Angle (radians)') plt.title('Angle vs Time: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show() # Plot Phase Diagram (Angle vs. Angular Velocity) plt.figure(figsize=(6, 6)) plt.plot(angle, angular_velocity) plt.xlabel('Angle (radians)') plt.ylabel('Angular Velocity (radians/s)') plt.title('Phase Diagram: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show() Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance) This scenario also involves a forced damped pendulum, but with parameters set to potentially exhibit chaotic behavior. This often occurs when the damping is relatively low and the external force is significant, especially if the frequency of the external force ( omega ) is close to the natural frequency of the pendulum (resonance). In a chaotic system, even tiny changes in initial conditions can lead to vastly different outcomes over time, and the motion is aperiodic and unpredictable in the long term. The phase diagram in a chaotic system will not settle into a simple limit cycle and can show complex, fractal-like structures (a strange attractor).","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Pendulum in physcics is a classic example of a system that exhibits periodic motion. A pendulum consists of a mass (the bob) attached to a string or rod that swings back and forth under the influence of gravity. The motion of the pendulum can be described by its period, which is the time it takes to complete one full swing, and its amplitude, which is the maximum distance from the equilibrium position.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pendulum-example","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of differential equations def pendulum_ode(t, y, b, g, L, A, omega): theta, omega_angular = y dydt = [omega_angular, A * np.cos(omega * t) - b * omega_angular - (g / L) * np.sin(theta)] return dydt # Set parameters (you can change these) g = 9.81 # acceleration due to gravity L = 1.0 # length of the pendulum t_span = [0, 20] # time span for simulation t_eval = np.linspace(t_span[0], t_span[1], 500) # points to evaluate the solution # Initial conditions (angle, angular velocity) initial_conditions = [np.pi / 4, 0] # Start at 45 degrees with zero initial velocity # Pure pendulum (b=0, A=0) b_pure = 0 A_pure = 0 omega_pure = 0 sol_pure = solve_ivp(pendulum_ode, t_span, initial_conditions, t_eval=t_eval, args=(b_pure, g, L, A_pure, omega_pure)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_pure.t, sol_pure.y[0]) plt.xlabel(\"Time (t)\") plt.ylabel(\"Angle (radians)\") plt.title(\"Angle vs Time (Pure Pendulum)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_pure.y[0], sol_pure.y[1]) plt.xlabel(\"Angle (radians)\") plt.ylabel(\"Angular Velocity (radians/s)\") plt.title(\"Phase Diagram (Pure Pendulum)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Pendulum Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-1-pure-pendulum-b0-a0","text":"This scenario represents the simplest case of a pendulum, where there is no damping (the resistance to motion due to friction or air resistance is zero, b=0 ) and no external force acting on the system ( A=0 ). The motion is purely governed by gravity. We expect to see simple harmonic motion (or close to it for small angles) with a constant amplitude and period. The phase diagram should show a closed elliptical path.","title":"Scenario 1: Pure Pendulum (b=0, A=0)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-2-pendulum-with-damping-b-0-a0","text":"In this scenario, we introduce damping to the pendulum ( b > 0 ), while still having no external force ( A=0 ). Damping causes the pendulum to lose energy over time, and its oscillations will gradually decrease in amplitude until it comes to rest at the equilibrium position (hanging straight down). The phase diagram should show a spiral path that converges towards the origin (0,0), representing the decrease in both angle and angular velocity.","title":"Scenario 2: Pendulum with Damping (b &gt; 0, A=0)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-3-pendulum-with-external-force-b0-a-0","text":"Here, we examine a pendulum with an external periodic force applied ( A > 0 ), but without any damping ( b=0 ). The external force continuously adds energy to the system. Depending on the frequency of the external force ( omega ), the pendulum's motion can become quite complex and may not settle into a stable oscillation. The phase diagram may show irregular or complex patterns, not necessarily closed loops or simple spirals.","title":"Scenario 3: Pendulum with External Force (b=0, A &gt; 0)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-4-forced-damped-pendulum-less-chaotic","text":"This scenario combines both damping ( b > 0 ) and an external force ( A > 0 ). With moderate damping, the system tends to reach a steady state where the energy added by the external force is balanced by the energy dissipated by damping. The motion is typically oscillatory and predictable, though the exact pattern depends on the parameters. The phase diagram might show a limit cycle, which is a stable, closed trajectory that the system settles into after an initial transient period. import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt # Define the pendulum equation def pendulum(y, t, b, g, l, A, omega): theta, omega_dot = y dydt = [omega_dot, -b * omega_dot - (g / l) * np.sin(theta) + A * np.cos(omega * t)] return dydt # --- Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance) --- b = 0.1 A = 1.2 omega = 0.95 # Near resonance # --- Common Parameters --- g = 9.81 # acceleration due to gravity l = 1.0 # length of the pendulum y0 = [np.pi / 4, 0.0] # initial conditions (angle, angular velocity) t = np.linspace(0, 100, 1001) # time points (extended for chaos) # Solve the differential equation sol = odeint(pendulum, y0, t, args=(b, g, l, A, omega)) angle = sol[:, 0] angular_velocity = sol[:, 1] # Plot Angle vs. Time plt.figure(figsize=(10, 4)) plt.plot(t, angle) plt.xlabel('Time') plt.ylabel('Angle (radians)') plt.title('Angle vs Time: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show() # Plot Phase Diagram (Angle vs. Angular Velocity) plt.figure(figsize=(6, 6)) plt.plot(angle, angular_velocity) plt.xlabel('Angle (radians)') plt.ylabel('Angular Velocity (radians/s)') plt.title('Phase Diagram: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show()","title":"Scenario 4: Forced Damped Pendulum (Less Chaotic)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-5-forced-damped-pendulum-more-chaotic-resonance","text":"This scenario also involves a forced damped pendulum, but with parameters set to potentially exhibit chaotic behavior. This often occurs when the damping is relatively low and the external force is significant, especially if the frequency of the external force ( omega ) is close to the natural frequency of the pendulum (resonance). In a chaotic system, even tiny changes in initial conditions can lead to vastly different outcomes over time, and the motion is aperiodic and unpredictable in the long term. The phase diagram in a chaotic system will not settle into a simple limit cycle and can show complex, fractal-like structures (a strange attractor).","title":"Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task 1. Derive the Relationship To derive the relationship between the square of the orbital period ( \\( T^2 \\) ) and the cube of the orbital radius ( \\( r^3 \\) ) for circular orbits, start with the balance of forces. The gravitational force on an orbiting body of mass \\( m \\) around a central mass \\( M \\) is: \\[ F = \\frac{G M m}{r^2} \\] The centripetal force required for circular motion at velocity \\( v \\) is: \\[ F = m \\frac{v^2}{r} \\] Equating these forces, we get the following aligned equations: \\[ \\begin{align} \\frac{G M m}{r^2} &= m \\frac{v^2}{r} \\\\ \\frac{G M}{r} &= v^2 \\\\ v &= \\sqrt{\\frac{G M}{r}} \\end{align} \\] The orbital period \\( T \\) is the time to complete one orbit, so the circumference \\( 2\\pi r \\) divided by the velocity \\( v \\) : \\[ \\begin{align} T &= \\frac{2\\pi r}{v} \\\\ &= \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\\\ &= 2\\pi r \\sqrt{\\frac{r}{G M}} \\\\ &= 2\\pi \\sqrt{\\frac{r^3}{G M}} \\end{align} \\] Square both sides to obtain: \\[ \\begin{align} T^2 &= \\left(2\\pi \\sqrt{\\frac{r^3}{G M}}\\right)^2 \\\\ &= (2\\pi)^2 \\frac{r^3}{G M} \\\\ &= \\frac{4\\pi^2}{G M} r^3 \\end{align} \\] Thus, \\(T^2 \\propto r^3\\) , and plotting \\( T^2 \\) vs. \\( r^3 \\) should yield a straight line with slope \\( \\frac{4\\pi^2}{G M} \\) . Note that ChatGPT's mention of an error in showing the line as straight is incorrect; the derivation confirms the relationship is linear. 2. Discuss the Implications Kepler's Third Law allows us to calculate planetary masses and distances: - Mass of the central body : By measuring \\( T \\) and \\( r \\) of an orbiting body (e.g., a moon or planet), we can determine \\( M \\) of the central body (e.g., a planet or star). - Orbital radius : If \\( M \\) is known, we can determine \\( r \\) from \\( T \\) , useful for satellites or exoplanets. - Period prediction : Knowing \\( r \\) , we can predict \\( T \\) , aiding in mission planning for spacecraft. 3. Analyze Real-World Examples Using data from Mercury, Venus, Earth, and Mars, we verify the relationship. The chart below plots \\( T^2 \\) vs. \\( r^3 \\) for these planets, showing a straight line as expected: import numpy as np import matplotlib.pyplot as plt # Define data for the inner planets (average orbital radius in AU, orbital period in Earth years) planets = { 'Mercury': {'r': 0.387, 'T': 0.241}, 'Venus': {'r': 0.723, 'T': 0.615}, 'Earth': {'r': 1.000, 'T': 1.000}, 'Mars': {'r': 1.524, 'T': 1.881} } # Calculate r^3 and T^2 for each planet r_cubed = [p['r']**3 for p in planets.values()] T_squared = [p['T']**2 for p in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 for the planets plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='red', label='Inner Planets') # Add labels to the data points for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') # Define a range of r values for the theoretical line r_theoretical = np.linspace(min(r_cubed)**(1/3) * 0.8, max(r_cubed)**(1/3) * 1.2, 100) # Extend range slightly T_squared_theoretical = r_theoretical**3 # In AU^3 and years^2, the constant is 1 # Plot the theoretical line plt.plot(r_theoretical**3, T_squared_theoretical, color='blue', linestyle='--', label='Kepler\\'s Law (T^2 = r^3)') plt.xlabel('r^3 (AU^3)') plt.ylabel('T^2 (years^2)') plt.title('T^2 vs r^3 for Inner Planets') plt.legend() plt.grid(True) plt.show() The data points are: - Mercury: \\( T = 7.601 \\times 10^6 \\) s, \\( r = 5.791 \\times 10^{10} \\) m, \\( T^2 = 5.777 \\times 10^{13} \\) s\u00b2, \\( r^3 = 1.942 \\times 10^{32} \\) m\u00b3 - Venus: \\( T = 1.941 \\times 10^7 \\) s, \\( r = 1.082 \\times 10^{11} \\) m, \\( T^2 = 3.767 \\times 10^{14} \\) s\u00b2, \\( r^3 = 1.266 \\times 10^{33} \\) m\u00b3 - Earth: \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m, \\( T^2 = 9.960 \\times 10^{14} \\) s\u00b2, \\( r^3 = 3.347 \\times 10^{33} \\) m\u00b3 - Mars: \\( T = 5.936 \\times 10^7 \\) s, \\( r = 2.279 \\times 10^{11} \\) m, \\( T^2 = 3.524 \\times 10^{15} \\) s\u00b2, \\( r^3 = 1.184 \\times 10^{34} \\) m\u00b3 The linear relationship is evident, confirming Kepler's Third Law in the Solar System. 4. Implement a Computational Model A computational model can simulate circular orbits by using Kepler's Third Law. Below, we calculate the masses of the Sun and Earth using real data. Mass of the Sun Using Earth's orbit around the Sun ( \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m): \\[ \\begin{align} M_{\\text{Sun}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11}) (3.156 \\times 10^7)^2} \\\\ &\\approx 1.982 \\times 10^{30} \\text{ kg} \\end{align} \\] Mass of the Earth Using the Moon's orbit around Earth ( \\( T = 2.360 \\times 10^6 \\) s, \\( r = 3.844 \\times 10^8 \\) m): \\[ \\begin{align} M_{\\text{Earth}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11}) (2.360 \\times 10^6)^2} \\\\ &\\approx 6.031 \\times 10^{24} \\text{ kg} \\end{align} \\] Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of circular orbits and the relationship between orbital period and radius. A discussion on how this relationship extends to elliptical orbits and other celestial bodies. Colab Link","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derive-the-relationship","text":"To derive the relationship between the square of the orbital period ( \\( T^2 \\) ) and the cube of the orbital radius ( \\( r^3 \\) ) for circular orbits, start with the balance of forces. The gravitational force on an orbiting body of mass \\( m \\) around a central mass \\( M \\) is: \\[ F = \\frac{G M m}{r^2} \\] The centripetal force required for circular motion at velocity \\( v \\) is: \\[ F = m \\frac{v^2}{r} \\] Equating these forces, we get the following aligned equations: \\[ \\begin{align} \\frac{G M m}{r^2} &= m \\frac{v^2}{r} \\\\ \\frac{G M}{r} &= v^2 \\\\ v &= \\sqrt{\\frac{G M}{r}} \\end{align} \\] The orbital period \\( T \\) is the time to complete one orbit, so the circumference \\( 2\\pi r \\) divided by the velocity \\( v \\) : \\[ \\begin{align} T &= \\frac{2\\pi r}{v} \\\\ &= \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\\\ &= 2\\pi r \\sqrt{\\frac{r}{G M}} \\\\ &= 2\\pi \\sqrt{\\frac{r^3}{G M}} \\end{align} \\] Square both sides to obtain: \\[ \\begin{align} T^2 &= \\left(2\\pi \\sqrt{\\frac{r^3}{G M}}\\right)^2 \\\\ &= (2\\pi)^2 \\frac{r^3}{G M} \\\\ &= \\frac{4\\pi^2}{G M} r^3 \\end{align} \\] Thus, \\(T^2 \\propto r^3\\) , and plotting \\( T^2 \\) vs. \\( r^3 \\) should yield a straight line with slope \\( \\frac{4\\pi^2}{G M} \\) . Note that ChatGPT's mention of an error in showing the line as straight is incorrect; the derivation confirms the relationship is linear.","title":"1. Derive the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-discuss-the-implications","text":"Kepler's Third Law allows us to calculate planetary masses and distances: - Mass of the central body : By measuring \\( T \\) and \\( r \\) of an orbiting body (e.g., a moon or planet), we can determine \\( M \\) of the central body (e.g., a planet or star). - Orbital radius : If \\( M \\) is known, we can determine \\( r \\) from \\( T \\) , useful for satellites or exoplanets. - Period prediction : Knowing \\( r \\) , we can predict \\( T \\) , aiding in mission planning for spacecraft.","title":"2. Discuss the Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-analyze-real-world-examples","text":"Using data from Mercury, Venus, Earth, and Mars, we verify the relationship. The chart below plots \\( T^2 \\) vs. \\( r^3 \\) for these planets, showing a straight line as expected: import numpy as np import matplotlib.pyplot as plt # Define data for the inner planets (average orbital radius in AU, orbital period in Earth years) planets = { 'Mercury': {'r': 0.387, 'T': 0.241}, 'Venus': {'r': 0.723, 'T': 0.615}, 'Earth': {'r': 1.000, 'T': 1.000}, 'Mars': {'r': 1.524, 'T': 1.881} } # Calculate r^3 and T^2 for each planet r_cubed = [p['r']**3 for p in planets.values()] T_squared = [p['T']**2 for p in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 for the planets plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='red', label='Inner Planets') # Add labels to the data points for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') # Define a range of r values for the theoretical line r_theoretical = np.linspace(min(r_cubed)**(1/3) * 0.8, max(r_cubed)**(1/3) * 1.2, 100) # Extend range slightly T_squared_theoretical = r_theoretical**3 # In AU^3 and years^2, the constant is 1 # Plot the theoretical line plt.plot(r_theoretical**3, T_squared_theoretical, color='blue', linestyle='--', label='Kepler\\'s Law (T^2 = r^3)') plt.xlabel('r^3 (AU^3)') plt.ylabel('T^2 (years^2)') plt.title('T^2 vs r^3 for Inner Planets') plt.legend() plt.grid(True) plt.show() The data points are: - Mercury: \\( T = 7.601 \\times 10^6 \\) s, \\( r = 5.791 \\times 10^{10} \\) m, \\( T^2 = 5.777 \\times 10^{13} \\) s\u00b2, \\( r^3 = 1.942 \\times 10^{32} \\) m\u00b3 - Venus: \\( T = 1.941 \\times 10^7 \\) s, \\( r = 1.082 \\times 10^{11} \\) m, \\( T^2 = 3.767 \\times 10^{14} \\) s\u00b2, \\( r^3 = 1.266 \\times 10^{33} \\) m\u00b3 - Earth: \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m, \\( T^2 = 9.960 \\times 10^{14} \\) s\u00b2, \\( r^3 = 3.347 \\times 10^{33} \\) m\u00b3 - Mars: \\( T = 5.936 \\times 10^7 \\) s, \\( r = 2.279 \\times 10^{11} \\) m, \\( T^2 = 3.524 \\times 10^{15} \\) s\u00b2, \\( r^3 = 1.184 \\times 10^{34} \\) m\u00b3 The linear relationship is evident, confirming Kepler's Third Law in the Solar System.","title":"3. Analyze Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implement-a-computational-model","text":"A computational model can simulate circular orbits by using Kepler's Third Law. Below, we calculate the masses of the Sun and Earth using real data.","title":"4. Implement a Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-of-the-sun","text":"Using Earth's orbit around the Sun ( \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m): \\[ \\begin{align} M_{\\text{Sun}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11}) (3.156 \\times 10^7)^2} \\\\ &\\approx 1.982 \\times 10^{30} \\text{ kg} \\end{align} \\]","title":"Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-of-the-earth","text":"Using the Moon's orbit around Earth ( \\( T = 2.360 \\times 10^6 \\) s, \\( r = 3.844 \\times 10^8 \\) m): \\[ \\begin{align} M_{\\text{Earth}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11}) (2.360 \\times 10^6)^2} \\\\ &\\approx 6.031 \\times 10^{24} \\text{ kg} \\end{align} \\]","title":"Mass of the Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of circular orbits and the relationship between orbital period and radius. A discussion on how this relationship extends to elliptical orbits and other celestial bodies. Colab Link","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2: Escape Velocities and Cosmic Velocities The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Solution 1. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) : This is the minimum speed needed for an object to orbit a celestial body at its surface, assuming no atmospheric drag. It is also called the circular orbital velocity. For a body of mass \\(M\\) and radius \\(R\\) , it is given by \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) , where \\(G\\) is the gravitational constant ( \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). Second Cosmic Velocity ( \\(v_2\\) ) : Known as the escape velocity, this is the minimum speed required for an object to escape the gravitational pull of a celestial body and not return. It is given by \\(v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This is the speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System) entirely, assuming it starts from the orbit of a planet like Earth. It depends on the distance from the star and the planet\u2019s orbital velocity. A simplified approximation for an object escaping the Sun from Earth's orbit is \\(v_3 \\approx \\sqrt{2} \\cdot v_{\\text{orbit}}\\) , where \\(v_{\\text{orbit}}\\) is Earth's orbital speed around the Sun. 2. Mathematical Derivations and Parameters The derivations for these velocities stem from energy conservation and gravitational physics: First Cosmic Velocity ( \\(v_1\\) ) : For a circular orbit, the centripetal force equals the gravitational force: \\(\\frac{m v_1^2}{R} = \\frac{G M m}{R^2}\\) , simplifying to \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) . Key parameters are \\(G\\) , \\(M\\) , and \\(R\\) . Second Cosmic Velocity ( \\(v_2\\) ) : To escape, the total mechanical energy must be zero: kinetic energy \\(\\frac{1}{2} m v_2^2\\) equals the potential energy \\(\\frac{G M m}{R}\\) , so \\(\\frac{1}{2} m v_2^2 = \\frac{G M m}{R}\\) , yielding \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This involves escaping the Sun\u2019s gravity from Earth\u2019s orbit. Earth\u2019s orbital speed around the Sun is \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r}}\\) , where \\(r\\) is the distance from the Sun (e.g., 1 AU for Earth). The escape velocity from the Sun at this distance is \\(\\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) . The third cosmic velocity is the additional speed needed beyond Earth\u2019s orbital speed, approximated as \\(v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) if starting from rest relative to the Sun, but adjusted for Earth\u2019s motion. Parameters affecting these velocities include the mass of the celestial body ( \\(M\\) ), its radius ( \\(R\\) ), and, for \\(v_3\\) , the distance from the star ( \\(r\\) ). Cosmic Velocities for Earth: First Cosmic Velocity (v1): 7.91 km/s (Orbital velocity just above surface) Second Cosmic Velocity (v2): 11.19 km/s (Escape velocity from Earth's surface) Escape Velocity from Sun at Earth's orbit: 42.13 km/s 3. Calculations and Visualization Let\u2019s calculate these velocities for Earth, Mars, and Jupiter using the following data: Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) . Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.390 \\times 10^6 \\, \\text{m}\\) . Jupiter : \\(M = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) . Sun (for \\(v_3\\) from Earth\u2019s orbit): \\(M_{\\text{Sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) , \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU). Python Script for Calculations import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.991e7} } sun_mass = 1.989e30 # Sun's mass (kg) earth_sun_distance = 1.496e11 # 1 AU (m) # Calculate velocities v1, v2, v3 = [], [], [] labels = [] for body, data in bodies.items(): M = data['mass'] R = data['radius'] # First cosmic velocity v1.append(np.sqrt(G * M / R) / 1000) # Convert to km/s # Second cosmic velocity v2.append(np.sqrt(2 * G * M / R) / 1000) # Convert to km/s # Third cosmic velocity (approximation from Earth's orbit around Sun) if body == 'Earth': v_sun_escape = np.sqrt(2 * G * sun_mass / earth_sun_distance) / 1000 # km/s v_orbit = np.sqrt(G * sun_mass / earth_sun_distance) / 1000 # km/s v3.append(v_sun_escape) # Simplified: total escape speed from Sun else: v3.append(None) # Only calculate v3 for Earth in this example labels.append(body) # Plotting (you can run this in a Jupyter notebook) plt.figure(figsize=(10, 6)) width = 0.25 x = np.arange(len(labels)) plt.bar(x - width, v1, width, label='First Cosmic Velocity (v1)', color='#1E90FF') plt.bar(x, v2, width, label='Second Cosmic Velocity (v2)', color='#FFD700') plt.bar(x + width, [v3[0], 0, 0], width, label='Third Cosmic Velocity (v3, Earth only)', color='#FF4500') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.show() Colab Colab Link","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#solution","text":"","title":"Solution"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"First Cosmic Velocity ( \\(v_1\\) ) : This is the minimum speed needed for an object to orbit a celestial body at its surface, assuming no atmospheric drag. It is also called the circular orbital velocity. For a body of mass \\(M\\) and radius \\(R\\) , it is given by \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) , where \\(G\\) is the gravitational constant ( \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). Second Cosmic Velocity ( \\(v_2\\) ) : Known as the escape velocity, this is the minimum speed required for an object to escape the gravitational pull of a celestial body and not return. It is given by \\(v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This is the speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System) entirely, assuming it starts from the orbit of a planet like Earth. It depends on the distance from the star and the planet\u2019s orbital velocity. A simplified approximation for an object escaping the Sun from Earth's orbit is \\(v_3 \\approx \\sqrt{2} \\cdot v_{\\text{orbit}}\\) , where \\(v_{\\text{orbit}}\\) is Earth's orbital speed around the Sun.","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-parameters","text":"The derivations for these velocities stem from energy conservation and gravitational physics: First Cosmic Velocity ( \\(v_1\\) ) : For a circular orbit, the centripetal force equals the gravitational force: \\(\\frac{m v_1^2}{R} = \\frac{G M m}{R^2}\\) , simplifying to \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) . Key parameters are \\(G\\) , \\(M\\) , and \\(R\\) . Second Cosmic Velocity ( \\(v_2\\) ) : To escape, the total mechanical energy must be zero: kinetic energy \\(\\frac{1}{2} m v_2^2\\) equals the potential energy \\(\\frac{G M m}{R}\\) , so \\(\\frac{1}{2} m v_2^2 = \\frac{G M m}{R}\\) , yielding \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This involves escaping the Sun\u2019s gravity from Earth\u2019s orbit. Earth\u2019s orbital speed around the Sun is \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r}}\\) , where \\(r\\) is the distance from the Sun (e.g., 1 AU for Earth). The escape velocity from the Sun at this distance is \\(\\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) . The third cosmic velocity is the additional speed needed beyond Earth\u2019s orbital speed, approximated as \\(v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) if starting from rest relative to the Sun, but adjusted for Earth\u2019s motion. Parameters affecting these velocities include the mass of the celestial body ( \\(M\\) ), its radius ( \\(R\\) ), and, for \\(v_3\\) , the distance from the star ( \\(r\\) ). Cosmic Velocities for Earth: First Cosmic Velocity (v1): 7.91 km/s (Orbital velocity just above surface) Second Cosmic Velocity (v2): 11.19 km/s (Escape velocity from Earth's surface) Escape Velocity from Sun at Earth's orbit: 42.13 km/s","title":"2. Mathematical Derivations and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-and-visualization","text":"Let\u2019s calculate these velocities for Earth, Mars, and Jupiter using the following data: Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) . Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.390 \\times 10^6 \\, \\text{m}\\) . Jupiter : \\(M = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) . Sun (for \\(v_3\\) from Earth\u2019s orbit): \\(M_{\\text{Sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) , \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU).","title":"3. Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script-for-calculations","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.991e7} } sun_mass = 1.989e30 # Sun's mass (kg) earth_sun_distance = 1.496e11 # 1 AU (m) # Calculate velocities v1, v2, v3 = [], [], [] labels = [] for body, data in bodies.items(): M = data['mass'] R = data['radius'] # First cosmic velocity v1.append(np.sqrt(G * M / R) / 1000) # Convert to km/s # Second cosmic velocity v2.append(np.sqrt(2 * G * M / R) / 1000) # Convert to km/s # Third cosmic velocity (approximation from Earth's orbit around Sun) if body == 'Earth': v_sun_escape = np.sqrt(2 * G * sun_mass / earth_sun_distance) / 1000 # km/s v_orbit = np.sqrt(G * sun_mass / earth_sun_distance) / 1000 # km/s v3.append(v_sun_escape) # Simplified: total escape speed from Sun else: v3.append(None) # Only calculate v3 for Earth in this example labels.append(body) # Plotting (you can run this in a Jupyter notebook) plt.figure(figsize=(10, 6)) width = 0.25 x = np.arange(len(labels)) plt.bar(x - width, v1, width, label='First Cosmic Velocity (v1)', color='#1E90FF') plt.bar(x, v2, width, label='Second Cosmic Velocity (v2)', color='#FFD700') plt.bar(x + width, [v3[0], 0, 0], width, label='Third Cosmic Velocity (v3, Earth only)', color='#FF4500') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.show()","title":"Python Script for Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Payload Trajectories Near Earth When a payload is released from a rocket near Earth, its path is governed by Newtonian gravity and initial conditions such as velocity, direction, and altitude. This document explores the types of trajectories possible\u2014elliptical, parabolic, or hyperbolic\u2014and simulates them using numerical integration. Physical Background The gravitational force acting on a payload of mass \\(m\\) due to the Earth (mass \\(M\\) ) is given by Newton\u2019s Law of Gravitation: \\[ \\vec{F}_g = - \\frac{G M m}{r^2} \\hat{r} \\] where: - \\(G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) is the gravitational constant, - \\(r\\) is the distance from the center of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the object to the Earth. The motion of the payload can be determined by solving Newton's second law: \\[ \\vec{a} = \\frac{\\vec{F}_g}{m} = - \\frac{G M}{r^2} \\hat{r} \\] Initial Conditions Altitude : 800 km above Earth's surface Earth radius : \\(R_E = 6371\\) km Initial position : \\(\\vec{r}_0 = (R_E + 800, 0)\\) km Initial velocities : 5 to 13 km/s in the tangential (positive y) direction Trajectory Types Elliptical orbit : \\(v < v_{\\text{escape}}\\) Parabolic escape : \\(v = v_{\\text{escape}}\\) Hyperbolic escape : \\(v > v_{\\text{escape}}\\) Escape velocity from a distance \\(r\\) is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} $$ Python Simulation The following Python code numerically integrates the motion using the Runge-Kutta method and plots the trajectory for various initial velocities. Earth is represented as a blue circle on the plot. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M = 5.972e24 # mass of Earth, kg R = 6.371e6 # radius of Earth, m rho = M / ((4/3) * np.pi * R**3) # average density of Earth def gravity_inside_earth(x, y): r = np.sqrt(x**2 + y**2) if r == 0: return 0, 0 g = -G * (4/3) * np.pi * rho * r return g * x / r, g * y / r def trajectory(t, state): x, y, vx, vy = state gx, gy = gravity_inside_earth(x, y) return [vx, vy, gx, gy] # Initial conditions def generate_initial_conditions(case=1): if case == 1: speeds = np.linspace(0, 8000, 6) # m/s pos = [R + 1e5, 0] else: speeds = np.linspace(1000, 11000, 11) pos = [R + 1e5, 0] return speeds, pos def simulate_trajectories(case=1): speeds, pos = generate_initial_conditions(case) t_span = (0, 20000) t_eval = np.linspace(*t_span, 1000) fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(f'Trajectories in a Gravitational Field with Filled Earth') ax.set_xlabel('x [m]') ax.set_ylabel('y [m]') ax.set_aspect('equal') # Earth earth = plt.Circle((0, 0), R, color='royalblue', alpha=0.5, label='Earth') ax.add_artist(earth) ax.plot(0, 0, marker='o', color='red', markersize=10, label='Center of Earth', markeredgecolor='black') for i, speed in enumerate(speeds): vx, vy = 0, speed sol = solve_ivp(trajectory, t_span, [pos[0], pos[1], vx, vy], t_eval=t_eval) ax.plot(sol.y[0], sol.y[1], label=f'Trajectory {i+1}') ax.set_xlim(-1.1*R, 1.1*R * (3 if case == 2 else 1.1)) ax.set_ylim(-1.1*R, 1.1*R * (3 if case == 2 else 1.1)) ax.legend() plt.grid(True) plt.show() # Case 1 simulate_trajectories(case=1) # Case 2 simulate_trajectories(case=2) Colab Colab Link","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#payload-trajectories-near-earth","text":"When a payload is released from a rocket near Earth, its path is governed by Newtonian gravity and initial conditions such as velocity, direction, and altitude. This document explores the types of trajectories possible\u2014elliptical, parabolic, or hyperbolic\u2014and simulates them using numerical integration.","title":"Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-background","text":"The gravitational force acting on a payload of mass \\(m\\) due to the Earth (mass \\(M\\) ) is given by Newton\u2019s Law of Gravitation: \\[ \\vec{F}_g = - \\frac{G M m}{r^2} \\hat{r} \\] where: - \\(G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) is the gravitational constant, - \\(r\\) is the distance from the center of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the object to the Earth. The motion of the payload can be determined by solving Newton's second law: \\[ \\vec{a} = \\frac{\\vec{F}_g}{m} = - \\frac{G M}{r^2} \\hat{r} \\]","title":"Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Altitude : 800 km above Earth's surface Earth radius : \\(R_E = 6371\\) km Initial position : \\(\\vec{r}_0 = (R_E + 800, 0)\\) km Initial velocities : 5 to 13 km/s in the tangential (positive y) direction","title":"Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types","text":"Elliptical orbit : \\(v < v_{\\text{escape}}\\) Parabolic escape : \\(v = v_{\\text{escape}}\\) Hyperbolic escape : \\(v > v_{\\text{escape}}\\) Escape velocity from a distance \\(r\\) is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} $$","title":"Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"The following Python code numerically integrates the motion using the Runge-Kutta method and plots the trajectory for various initial velocities. Earth is represented as a blue circle on the plot. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M = 5.972e24 # mass of Earth, kg R = 6.371e6 # radius of Earth, m rho = M / ((4/3) * np.pi * R**3) # average density of Earth def gravity_inside_earth(x, y): r = np.sqrt(x**2 + y**2) if r == 0: return 0, 0 g = -G * (4/3) * np.pi * rho * r return g * x / r, g * y / r def trajectory(t, state): x, y, vx, vy = state gx, gy = gravity_inside_earth(x, y) return [vx, vy, gx, gy] # Initial conditions def generate_initial_conditions(case=1): if case == 1: speeds = np.linspace(0, 8000, 6) # m/s pos = [R + 1e5, 0] else: speeds = np.linspace(1000, 11000, 11) pos = [R + 1e5, 0] return speeds, pos def simulate_trajectories(case=1): speeds, pos = generate_initial_conditions(case) t_span = (0, 20000) t_eval = np.linspace(*t_span, 1000) fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(f'Trajectories in a Gravitational Field with Filled Earth') ax.set_xlabel('x [m]') ax.set_ylabel('y [m]') ax.set_aspect('equal') # Earth earth = plt.Circle((0, 0), R, color='royalblue', alpha=0.5, label='Earth') ax.add_artist(earth) ax.plot(0, 0, marker='o', color='red', markersize=10, label='Center of Earth', markeredgecolor='black') for i, speed in enumerate(speeds): vx, vy = 0, speed sol = solve_ivp(trajectory, t_span, [pos[0], pos[1], vx, vy], t_eval=t_eval) ax.plot(sol.y[0], sol.y[1], label=f'Trajectory {i+1}') ax.set_xlim(-1.1*R, 1.1*R * (3 if case == 2 else 1.1)) ax.set_ylim(-1.1*R, 1.1*R * (3 if case == 2 else 1.1)) ax.legend() plt.grid(True) plt.show() # Case 1 simulate_trajectories(case=1) # Case 2 simulate_trajectories(case=2)","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Solution Step 1: Select a Regular Polygon Let's choose a square as the regular polygon, with vertices at coordinates \\((0,0)\\) , \\((1,0)\\) , \\((1,1)\\) , and \\((0,1)\\) . Each vertex will have a point source emitting waves. Step 2: Position the Sources The sources are placed at the vertices of the square: - Source 1: \\((0,0)\\) - Source 2: \\((1,0)\\) - Source 3: \\((1,1)\\) - Source 4: \\((0,1)\\) Step 3: Wave Equations Each source emits a wave with amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , wave number \\(k = \\frac{2\\pi}{\\lambda}\\) , and angular frequency \\(\\omega = 2\\pi f\\) . The wave from a source at \\((x_i, y_i)\\) to a point \\((x, y)\\) at time \\(t\\) is given by: Distance from source to point: \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) Wave equation: \\(\\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi)\\) Since all sources have the same phase, we set \\(\\phi = 0\\) . Thus, for each source: - Source 1 at \\((0,0)\\) : \\(r_1 = \\sqrt{x^2 + y^2}\\) , \\(\\eta_1(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t)\\) - Source 2 at \\((1,0)\\) : \\(r_2 = \\sqrt{(x-1)^2 + y^2}\\) , \\(\\eta_2(x, y, t) = \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t)\\) - Source 3 at \\((1,1)\\) : \\(r_3 = \\sqrt{(x-1)^2 + (y-1)^2}\\) , \\(\\eta_3(x, y, t) = \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t)\\) - Source 4 at \\((0,1)\\) : \\(r_4 = \\sqrt{x^2 + (y-1)^2}\\) , \\(\\eta_4(x, y, t) = \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\) Step 4: Superposition of Waves The total displacement at point \\((x, y)\\) and time \\(t\\) is the sum of the waves from all sources: \\(\\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) + \\eta_3(x, y, t) + \\eta_4(x, y, t)\\) So, \\(\\eta_{\\text{sum}}(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t) + \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t) + \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t) + \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\) Step 5: Analyze Interference Patterns Constructive Interference : Occurs when the waves are in phase, i.e., the path difference \\(r_i - r_j\\) is a multiple of \\(\\lambda\\) . For example, at the center of the square \\((0.5, 0.5)\\) , calculate \\(r_i\\) from each source to check for constructive interference. Destructive Interference : Occurs when the waves are out of phase by \\(\\pi\\) , i.e., the path difference is an odd multiple of \\(\\frac{\\lambda}{2}\\) . This can be observed along lines where waves cancel out. Step 6: Visualization To visualize the interference patterns, use Python with Matplotlib to plot the total displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) over a 2D grid at a fixed time \\(t\\) . A heatmap or contour plot can illustrate regions of constructive and destructive interference effectively. import numpy as np import matplotlib.pyplot as plt import plotly.graph_objects as go from matplotlib import animation from IPython.display import HTML def create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed): \"\"\"Creates a wave from a single source.\"\"\" distance = np.sqrt((x - source_x)**2 + (y - source_y)**2) wave = amplitude * np.sin(2 * np.pi * (distance / wavelength - time * speed / wavelength)) return wave # Define parameters grid_size = 100 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) source_x, source_y = 0, 0 amplitude = 1 wavelength = 1 speed = 1 time = 0 # Generate wave data wave_data = create_wave(X, Y, source_x, source_y, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(wave_data, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Wave from One Source (Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=wave_data, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Wave from One Source (3D)', scene = dict( xaxis_title='X', yaxis_title='Y', zaxis_title='Amplitude')) fig.show() def create_interference(x, y, sources, amplitude, wavelength, time, speed): \"\"\"Creates interference pattern from multiple sources.\"\"\" total_wave = np.zeros_like(x) for source_x, source_y in sources: total_wave += create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed) return total_wave # Define parameters for two sources sources_two = [( -2, 0), (2, 0)] # Source positions time = 0 # Generate interference data interference_data_two = create_interference(X, Y, sources_two, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(interference_data_two, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Interference Pattern (Two Sources - Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=interference_data_two, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Interference Pattern (Two Sources - 3D)', scene = dict( xaxis_title='X', yaxis_title='Y', Colab Colab Link","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-solution","text":"","title":"Wave Interference Solution"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-select-a-regular-polygon","text":"Let's choose a square as the regular polygon, with vertices at coordinates \\((0,0)\\) , \\((1,0)\\) , \\((1,1)\\) , and \\((0,1)\\) . Each vertex will have a point source emitting waves.","title":"Step 1: Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-position-the-sources","text":"The sources are placed at the vertices of the square: - Source 1: \\((0,0)\\) - Source 2: \\((1,0)\\) - Source 3: \\((1,1)\\) - Source 4: \\((0,1)\\)","title":"Step 2: Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-wave-equations","text":"Each source emits a wave with amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , wave number \\(k = \\frac{2\\pi}{\\lambda}\\) , and angular frequency \\(\\omega = 2\\pi f\\) . The wave from a source at \\((x_i, y_i)\\) to a point \\((x, y)\\) at time \\(t\\) is given by: Distance from source to point: \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) Wave equation: \\(\\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi)\\) Since all sources have the same phase, we set \\(\\phi = 0\\) . Thus, for each source: - Source 1 at \\((0,0)\\) : \\(r_1 = \\sqrt{x^2 + y^2}\\) , \\(\\eta_1(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t)\\) - Source 2 at \\((1,0)\\) : \\(r_2 = \\sqrt{(x-1)^2 + y^2}\\) , \\(\\eta_2(x, y, t) = \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t)\\) - Source 3 at \\((1,1)\\) : \\(r_3 = \\sqrt{(x-1)^2 + (y-1)^2}\\) , \\(\\eta_3(x, y, t) = \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t)\\) - Source 4 at \\((0,1)\\) : \\(r_4 = \\sqrt{x^2 + (y-1)^2}\\) , \\(\\eta_4(x, y, t) = \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\)","title":"Step 3: Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-superposition-of-waves","text":"The total displacement at point \\((x, y)\\) and time \\(t\\) is the sum of the waves from all sources: \\(\\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) + \\eta_3(x, y, t) + \\eta_4(x, y, t)\\) So, \\(\\eta_{\\text{sum}}(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t) + \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t) + \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t) + \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\)","title":"Step 4: Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-5-analyze-interference-patterns","text":"Constructive Interference : Occurs when the waves are in phase, i.e., the path difference \\(r_i - r_j\\) is a multiple of \\(\\lambda\\) . For example, at the center of the square \\((0.5, 0.5)\\) , calculate \\(r_i\\) from each source to check for constructive interference. Destructive Interference : Occurs when the waves are out of phase by \\(\\pi\\) , i.e., the path difference is an odd multiple of \\(\\frac{\\lambda}{2}\\) . This can be observed along lines where waves cancel out.","title":"Step 5: Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-6-visualization","text":"To visualize the interference patterns, use Python with Matplotlib to plot the total displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) over a 2D grid at a fixed time \\(t\\) . A heatmap or contour plot can illustrate regions of constructive and destructive interference effectively. import numpy as np import matplotlib.pyplot as plt import plotly.graph_objects as go from matplotlib import animation from IPython.display import HTML def create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed): \"\"\"Creates a wave from a single source.\"\"\" distance = np.sqrt((x - source_x)**2 + (y - source_y)**2) wave = amplitude * np.sin(2 * np.pi * (distance / wavelength - time * speed / wavelength)) return wave # Define parameters grid_size = 100 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) source_x, source_y = 0, 0 amplitude = 1 wavelength = 1 speed = 1 time = 0 # Generate wave data wave_data = create_wave(X, Y, source_x, source_y, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(wave_data, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Wave from One Source (Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=wave_data, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Wave from One Source (3D)', scene = dict( xaxis_title='X', yaxis_title='Y', zaxis_title='Amplitude')) fig.show() def create_interference(x, y, sources, amplitude, wavelength, time, speed): \"\"\"Creates interference pattern from multiple sources.\"\"\" total_wave = np.zeros_like(x) for source_x, source_y in sources: total_wave += create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed) return total_wave # Define parameters for two sources sources_two = [( -2, 0), (2, 0)] # Source positions time = 0 # Generate interference data interference_data_two = create_interference(X, Y, sources_two, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(interference_data_two, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Interference Pattern (Two Sources - Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=interference_data_two, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Interference Pattern (Two Sources - 3D)', scene = dict( xaxis_title='X', yaxis_title='Y',","title":"Step 6: Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}