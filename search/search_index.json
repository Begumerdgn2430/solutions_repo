{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 . \ud83c\udfaf Investigating the Range as a Function of the Angle of Projection Derivation of the General Solution from the Laws of Motion We begin with Newton's Second Law of Motion: \\[ \\vec{F} = m \\vec{a} \\] This implies that the net force acting on a body is equal to the mass of the body multiplied by its acceleration. 1. Motion in One Dimension Consider motion along the x-axis with constant acceleration \\(a\\) . From the definition of acceleration: \\[ a = \\frac{dv}{dt} \\] Integrating both sides with respect to time: \\[ \\int a \\, dt = \\int \\frac{dv}{dt} \\, dt \\Rightarrow at + C_1 = v(t) \\] Letting \\(v_0\\) be the initial velocity at \\(t = 0\\) , we find \\(C_1 = v_0\\) , so: \\[ v(t) = v_0 + at \\] Now, velocity is the derivative of position: \\[ v = \\frac{dx}{dt} \\] Integrating again: \\[ \\int v \\, dt = \\int (v_0 + at) \\, dt = v_0 t + \\frac{1}{2} a t^2 + C_2 \\] Letting \\(x_0\\) be the initial position at \\(t = 0\\) , we find \\(C_2 = x_0\\) , giving the position function: \\[ x(t) = x_0 + v_0 t + \\frac{1}{2} a t^2 \\] 2. General Solution in Two Dimensions We now extend the solution to two-dimensional motion with constant acceleration. Let \\(\\vec{r}(t) = (x(t), y(t))\\) , \\(\\vec{v}(t) = (v_x(t), v_y(t))\\) , and \\(\\vec{a} = (a_x, a_y)\\) . Using the same integration steps for each component: Velocity components: \\[ v_x(t) = v_{0x} + a_x t \\] \\[ v_y(t) = v_{0y} + a_y t \\] Position components: \\[ x(t) = x_0 + v_{0x} t + \\frac{1}{2} a_x t^2 \\] \\[ y(t) = y_0 + v_{0y} t + \\frac{1}{2} a_y t^2 \\] Thus, the general vector solution is: \\[ \\vec{r}(t) = \\vec{r}_0 + \\vec{v}_0 t + \\frac{1}{2} \\vec{a} t^2 \\] where: \\(\\vec{r}_0 = (x_0, y_0)\\) is the initial position, \\(\\vec{v}_0 = (v_{0x}, v_{0y})\\) is the initial velocity, \\(\\vec{a} = (a_x, a_y)\\) is the constant acceleration. This equation describes the position of a particle under constant acceleration in two-dimensional space. 2. Theoretical Foundation \ud83e\uddee Velocity Components: Horizontal: \\(v_{0x} = v_0 \\cos(\\theta)\\) Vertical: \\(v_{0y} = v_0 \\sin(\\theta)\\) \u23f1\ufe0f Time of Flight: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] \ud83d\udccf Range: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum range occurs at \\(\\theta = 45^\\circ\\) Doubling \\(v_0\\) quadruples the range 3. Graphical Analysis \ud83d\udcca Plot 1: Range vs Angle for Different Velocities This graph shows how the range changes with angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . All curves peak at \\(45^\\circ\\) , confirming it as the optimal launch angle. \ud83d\udcca Plot 2: Range vs Angle on Different Planets Here, \\(v_0 = 20 \\, \\text{m/s}\\) and we compare projectile ranges on Earth , Moon , and Mars . The lower the gravity, the longer the projectile stays in the air, resulting in greater range. \ud83d\udcca Plot 3: Trajectories from Different Initial Heights This graph uses a fixed angle ( \\(\\theta = 45^\\circ\\) ) and velocity ( \\(v_0 = 20\\, \\text{m/s}\\) ), but launches the projectile from various heights ( \\(h = 0, 5, 10\\, \\text{m}\\) ). As expected, higher launch points result in longer range and higher peak. \ud83d\udcca Plot 4: Trajectories at Multiple Angles Here we show the paths of projectiles launched at the same speed ( \\(v_0 = 20\\, \\text{m/s}\\) ) but with different angles: \\(15^\\circ\\) , \\(39^\\circ\\) , \\(45^\\circ\\) , \\(60^\\circ\\) , and \\(75^\\circ\\) . It visually demonstrates how lower angles have flatter paths and shorter airtime. \ud83d\udcca Plot 5: With vs Without Air Resistance This comparison plot shows the difference in trajectories when air resistance is considered. While real drag modeling is complex, we simulate a simplified scenario showing that air resistance reduces both range and peak height. 4. Insights and Applications 45\u00b0 is the optimal angle for range under ideal (no air) conditions. Air resistance significantly shortens the range and reduces height. Different planets yield different results due to varying gravity. Initial height adds more airtime and therefore greater range. These concepts are important in: - Sports physics (kicking, throwing) - Military ballistics - Spacecraft launches - Engineering simulations 5. Conclusion With physics equations and computational tools, we effectively analyzed how a projectile behaves under various scenarios. Graphical analysis helped confirm theoretical expectations and made the results more intuitive. Simulate It with Python Here\u2019s some Python code that calculates the range for different angles and plots import numpy as np import matplotlib.pyplot as plt # Gravity and initial speed g = 9.81 # m/s^2 v0 = 20.0 # m/s # Try angles from 0 to 90 degrees angles_deg = np.linspace(0, 90, 100) angles_rad = np.radians(angles_deg) # Calculate the range for each angle ranges = (v0 ** 2) * np.sin(2 * angles_rad) / g # Plot it plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges) plt.title(\"How Far Does It Go? Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.axvline(x=45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.legend() plt.tight_layout() plt.show() Final The sweet spot for distance is 45\u00b0\u2014that\u2019s when the projectile goes the farthest. The graph is symmetric: launching at 30\u00b0 gives you the same range as 60\u00b0. If you increase the launch speed, the range increases a lot (since it\u2019s based on \\(v_0^2\\) ).","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":".","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83c\udfaf Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-the-general-solution-from-the-laws-of-motion","text":"We begin with Newton's Second Law of Motion: \\[ \\vec{F} = m \\vec{a} \\] This implies that the net force acting on a body is equal to the mass of the body multiplied by its acceleration.","title":"Derivation of the General Solution from the Laws of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motion-in-one-dimension","text":"Consider motion along the x-axis with constant acceleration \\(a\\) . From the definition of acceleration: \\[ a = \\frac{dv}{dt} \\] Integrating both sides with respect to time: \\[ \\int a \\, dt = \\int \\frac{dv}{dt} \\, dt \\Rightarrow at + C_1 = v(t) \\] Letting \\(v_0\\) be the initial velocity at \\(t = 0\\) , we find \\(C_1 = v_0\\) , so: \\[ v(t) = v_0 + at \\] Now, velocity is the derivative of position: \\[ v = \\frac{dx}{dt} \\] Integrating again: \\[ \\int v \\, dt = \\int (v_0 + at) \\, dt = v_0 t + \\frac{1}{2} a t^2 + C_2 \\] Letting \\(x_0\\) be the initial position at \\(t = 0\\) , we find \\(C_2 = x_0\\) , giving the position function: \\[ x(t) = x_0 + v_0 t + \\frac{1}{2} a t^2 \\]","title":"1. Motion in One Dimension"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-general-solution-in-two-dimensions","text":"We now extend the solution to two-dimensional motion with constant acceleration. Let \\(\\vec{r}(t) = (x(t), y(t))\\) , \\(\\vec{v}(t) = (v_x(t), v_y(t))\\) , and \\(\\vec{a} = (a_x, a_y)\\) . Using the same integration steps for each component:","title":"2. General Solution in Two Dimensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#velocity-components","text":"\\[ v_x(t) = v_{0x} + a_x t \\] \\[ v_y(t) = v_{0y} + a_y t \\]","title":"Velocity components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#position-components","text":"\\[ x(t) = x_0 + v_{0x} t + \\frac{1}{2} a_x t^2 \\] \\[ y(t) = y_0 + v_{0y} t + \\frac{1}{2} a_y t^2 \\] Thus, the general vector solution is: \\[ \\vec{r}(t) = \\vec{r}_0 + \\vec{v}_0 t + \\frac{1}{2} \\vec{a} t^2 \\] where: \\(\\vec{r}_0 = (x_0, y_0)\\) is the initial position, \\(\\vec{v}_0 = (v_{0x}, v_{0y})\\) is the initial velocity, \\(\\vec{a} = (a_x, a_y)\\) is the constant acceleration. This equation describes the position of a particle under constant acceleration in two-dimensional space.","title":"Position components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#velocity-components_1","text":"Horizontal: \\(v_{0x} = v_0 \\cos(\\theta)\\) Vertical: \\(v_{0y} = v_0 \\sin(\\theta)\\)","title":"\ud83e\uddee Velocity Components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"\\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"\u23f1\ufe0f Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"\\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum range occurs at \\(\\theta = 45^\\circ\\) Doubling \\(v_0\\) quadruples the range","title":"\ud83d\udccf Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-graphical-analysis","text":"","title":"3. Graphical Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-1-range-vs-angle-for-different-velocities","text":"This graph shows how the range changes with angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . All curves peak at \\(45^\\circ\\) , confirming it as the optimal launch angle.","title":"\ud83d\udcca Plot 1: Range vs Angle for Different Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-2-range-vs-angle-on-different-planets","text":"Here, \\(v_0 = 20 \\, \\text{m/s}\\) and we compare projectile ranges on Earth , Moon , and Mars . The lower the gravity, the longer the projectile stays in the air, resulting in greater range.","title":"\ud83d\udcca Plot 2: Range vs Angle on Different Planets"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-3-trajectories-from-different-initial-heights","text":"This graph uses a fixed angle ( \\(\\theta = 45^\\circ\\) ) and velocity ( \\(v_0 = 20\\, \\text{m/s}\\) ), but launches the projectile from various heights ( \\(h = 0, 5, 10\\, \\text{m}\\) ). As expected, higher launch points result in longer range and higher peak.","title":"\ud83d\udcca Plot 3: Trajectories from Different Initial Heights"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-4-trajectories-at-multiple-angles","text":"Here we show the paths of projectiles launched at the same speed ( \\(v_0 = 20\\, \\text{m/s}\\) ) but with different angles: \\(15^\\circ\\) , \\(39^\\circ\\) , \\(45^\\circ\\) , \\(60^\\circ\\) , and \\(75^\\circ\\) . It visually demonstrates how lower angles have flatter paths and shorter airtime.","title":"\ud83d\udcca Plot 4: Trajectories at Multiple Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-5-with-vs-without-air-resistance","text":"This comparison plot shows the difference in trajectories when air resistance is considered. While real drag modeling is complex, we simulate a simplified scenario showing that air resistance reduces both range and peak height.","title":"\ud83d\udcca Plot 5: With vs Without Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-insights-and-applications","text":"45\u00b0 is the optimal angle for range under ideal (no air) conditions. Air resistance significantly shortens the range and reduces height. Different planets yield different results due to varying gravity. Initial height adds more airtime and therefore greater range. These concepts are important in: - Sports physics (kicking, throwing) - Military ballistics - Spacecraft launches - Engineering simulations","title":"4. Insights and Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-conclusion","text":"With physics equations and computational tools, we effectively analyzed how a projectile behaves under various scenarios. Graphical analysis helped confirm theoretical expectations and made the results more intuitive.","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulate-it-with-python","text":"Here\u2019s some Python code that calculates the range for different angles and plots import numpy as np import matplotlib.pyplot as plt # Gravity and initial speed g = 9.81 # m/s^2 v0 = 20.0 # m/s # Try angles from 0 to 90 degrees angles_deg = np.linspace(0, 90, 100) angles_rad = np.radians(angles_deg) # Calculate the range for each angle ranges = (v0 ** 2) * np.sin(2 * angles_rad) / g # Plot it plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges) plt.title(\"How Far Does It Go? Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.axvline(x=45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.legend() plt.tight_layout() plt.show()","title":"Simulate It with Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#final","text":"The sweet spot for distance is 45\u00b0\u2014that\u2019s when the projectile goes the farthest. The graph is symmetric: launching at 30\u00b0 gives you the same range as 60\u00b0. If you increase the launch speed, the range increases a lot (since it\u2019s based on \\(v_0^2\\) ).","title":"Final"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Pendulum in physcics is a classic example of a system that exhibits periodic motion. A pendulum consists of a mass (the bob) attached to a string or rod that swings back and forth under the influence of gravity. The motion of the pendulum can be described by its period, which is the time it takes to complete one full swing, and its amplitude, which is the maximum distance from the equilibrium position. Colab Colab Link Pendulum Example import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of differential equations def pendulum_ode(t, y, b, g, L, A, omega): theta, omega_angular = y dydt = [omega_angular, A * np.cos(omega * t) - b * omega_angular - (g / L) * np.sin(theta)] return dydt # Set parameters (you can change these) g = 9.81 # acceleration due to gravity L = 1.0 # length of the pendulum t_span = [0, 20] # time span for simulation t_eval = np.linspace(t_span[0], t_span[1], 500) # points to evaluate the solution # Initial conditions (angle, angular velocity) initial_conditions = [np.pi / 4, 0] # Start at 45 degrees with zero initial velocity # Pure pendulum (b=0, A=0) b_pure = 0 A_pure = 0 omega_pure = 0 sol_pure = solve_ivp(pendulum_ode, t_span, initial_conditions, t_eval=t_eval, args=(b_pure, g, L, A_pure, omega_pure)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_pure.t, sol_pure.y[0]) plt.xlabel(\"Time (t)\") plt.ylabel(\"Angle (radians)\") plt.title(\"Angle vs Time (Pure Pendulum)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_pure.y[0], sol_pure.y[1]) plt.xlabel(\"Angle (radians)\") plt.ylabel(\"Angular Velocity (radians/s)\") plt.title(\"Phase Diagram (Pure Pendulum)\") plt.grid(True) plt.tight_layout() plt.show() Scenario 1: Pure Pendulum (b=0, A=0) This scenario represents the simplest case of a pendulum, where there is no damping (the resistance to motion due to friction or air resistance is zero, b=0 ) and no external force acting on the system ( A=0 ). The motion is purely governed by gravity. We expect to see simple harmonic motion (or close to it for small angles) with a constant amplitude and period. The phase diagram should show a closed elliptical path. Scenario 2: Pendulum with Damping (b > 0, A=0) In this scenario, we introduce damping to the pendulum ( b > 0 ), while still having no external force ( A=0 ). Damping causes the pendulum to lose energy over time, and its oscillations will gradually decrease in amplitude until it comes to rest at the equilibrium position (hanging straight down). The phase diagram should show a spiral path that converges towards the origin (0,0), representing the decrease in both angle and angular velocity. Scenario 3: Pendulum with External Force (b=0, A > 0) Here, we examine a pendulum with an external periodic force applied ( A > 0 ), but without any damping ( b=0 ). The external force continuously adds energy to the system. Depending on the frequency of the external force ( omega ), the pendulum's motion can become quite complex and may not settle into a stable oscillation. The phase diagram may show irregular or complex patterns, not necessarily closed loops or simple spirals. Scenario 4: Forced Damped Pendulum (Less Chaotic) This scenario combines both damping ( b > 0 ) and an external force ( A > 0 ). With moderate damping, the system tends to reach a steady state where the energy added by the external force is balanced by the energy dissipated by damping. The motion is typically oscillatory and predictable, though the exact pattern depends on the parameters. The phase diagram might show a limit cycle, which is a stable, closed trajectory that the system settles into after an initial transient period. import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt # Define the pendulum equation def pendulum(y, t, b, g, l, A, omega): theta, omega_dot = y dydt = [omega_dot, -b * omega_dot - (g / l) * np.sin(theta) + A * np.cos(omega * t)] return dydt # --- Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance) --- b = 0.1 A = 1.2 omega = 0.95 # Near resonance # --- Common Parameters --- g = 9.81 # acceleration due to gravity l = 1.0 # length of the pendulum y0 = [np.pi / 4, 0.0] # initial conditions (angle, angular velocity) t = np.linspace(0, 100, 1001) # time points (extended for chaos) # Solve the differential equation sol = odeint(pendulum, y0, t, args=(b, g, l, A, omega)) angle = sol[:, 0] angular_velocity = sol[:, 1] # Plot Angle vs. Time plt.figure(figsize=(10, 4)) plt.plot(t, angle) plt.xlabel('Time') plt.ylabel('Angle (radians)') plt.title('Angle vs Time: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show() # Plot Phase Diagram (Angle vs. Angular Velocity) plt.figure(figsize=(6, 6)) plt.plot(angle, angular_velocity) plt.xlabel('Angle (radians)') plt.ylabel('Angular Velocity (radians/s)') plt.title('Phase Diagram: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show() Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance) This scenario also involves a forced damped pendulum, but with parameters set to potentially exhibit chaotic behavior. This often occurs when the damping is relatively low and the external force is significant, especially if the frequency of the external force ( omega ) is close to the natural frequency of the pendulum (resonance). In a chaotic system, even tiny changes in initial conditions can lead to vastly different outcomes over time, and the motion is aperiodic and unpredictable in the long term. The phase diagram in a chaotic system will not settle into a simple limit cycle and can show complex, fractal-like structures (a strange attractor).","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Pendulum in physcics is a classic example of a system that exhibits periodic motion. A pendulum consists of a mass (the bob) attached to a string or rod that swings back and forth under the influence of gravity. The motion of the pendulum can be described by its period, which is the time it takes to complete one full swing, and its amplitude, which is the maximum distance from the equilibrium position.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pendulum-example","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of differential equations def pendulum_ode(t, y, b, g, L, A, omega): theta, omega_angular = y dydt = [omega_angular, A * np.cos(omega * t) - b * omega_angular - (g / L) * np.sin(theta)] return dydt # Set parameters (you can change these) g = 9.81 # acceleration due to gravity L = 1.0 # length of the pendulum t_span = [0, 20] # time span for simulation t_eval = np.linspace(t_span[0], t_span[1], 500) # points to evaluate the solution # Initial conditions (angle, angular velocity) initial_conditions = [np.pi / 4, 0] # Start at 45 degrees with zero initial velocity # Pure pendulum (b=0, A=0) b_pure = 0 A_pure = 0 omega_pure = 0 sol_pure = solve_ivp(pendulum_ode, t_span, initial_conditions, t_eval=t_eval, args=(b_pure, g, L, A_pure, omega_pure)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_pure.t, sol_pure.y[0]) plt.xlabel(\"Time (t)\") plt.ylabel(\"Angle (radians)\") plt.title(\"Angle vs Time (Pure Pendulum)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_pure.y[0], sol_pure.y[1]) plt.xlabel(\"Angle (radians)\") plt.ylabel(\"Angular Velocity (radians/s)\") plt.title(\"Phase Diagram (Pure Pendulum)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Pendulum Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-1-pure-pendulum-b0-a0","text":"This scenario represents the simplest case of a pendulum, where there is no damping (the resistance to motion due to friction or air resistance is zero, b=0 ) and no external force acting on the system ( A=0 ). The motion is purely governed by gravity. We expect to see simple harmonic motion (or close to it for small angles) with a constant amplitude and period. The phase diagram should show a closed elliptical path.","title":"Scenario 1: Pure Pendulum (b=0, A=0)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-2-pendulum-with-damping-b-0-a0","text":"In this scenario, we introduce damping to the pendulum ( b > 0 ), while still having no external force ( A=0 ). Damping causes the pendulum to lose energy over time, and its oscillations will gradually decrease in amplitude until it comes to rest at the equilibrium position (hanging straight down). The phase diagram should show a spiral path that converges towards the origin (0,0), representing the decrease in both angle and angular velocity.","title":"Scenario 2: Pendulum with Damping (b &gt; 0, A=0)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-3-pendulum-with-external-force-b0-a-0","text":"Here, we examine a pendulum with an external periodic force applied ( A > 0 ), but without any damping ( b=0 ). The external force continuously adds energy to the system. Depending on the frequency of the external force ( omega ), the pendulum's motion can become quite complex and may not settle into a stable oscillation. The phase diagram may show irregular or complex patterns, not necessarily closed loops or simple spirals.","title":"Scenario 3: Pendulum with External Force (b=0, A &gt; 0)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-4-forced-damped-pendulum-less-chaotic","text":"This scenario combines both damping ( b > 0 ) and an external force ( A > 0 ). With moderate damping, the system tends to reach a steady state where the energy added by the external force is balanced by the energy dissipated by damping. The motion is typically oscillatory and predictable, though the exact pattern depends on the parameters. The phase diagram might show a limit cycle, which is a stable, closed trajectory that the system settles into after an initial transient period. import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt # Define the pendulum equation def pendulum(y, t, b, g, l, A, omega): theta, omega_dot = y dydt = [omega_dot, -b * omega_dot - (g / l) * np.sin(theta) + A * np.cos(omega * t)] return dydt # --- Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance) --- b = 0.1 A = 1.2 omega = 0.95 # Near resonance # --- Common Parameters --- g = 9.81 # acceleration due to gravity l = 1.0 # length of the pendulum y0 = [np.pi / 4, 0.0] # initial conditions (angle, angular velocity) t = np.linspace(0, 100, 1001) # time points (extended for chaos) # Solve the differential equation sol = odeint(pendulum, y0, t, args=(b, g, l, A, omega)) angle = sol[:, 0] angular_velocity = sol[:, 1] # Plot Angle vs. Time plt.figure(figsize=(10, 4)) plt.plot(t, angle) plt.xlabel('Time') plt.ylabel('Angle (radians)') plt.title('Angle vs Time: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show() # Plot Phase Diagram (Angle vs. Angular Velocity) plt.figure(figsize=(6, 6)) plt.plot(angle, angular_velocity) plt.xlabel('Angle (radians)') plt.ylabel('Angular Velocity (radians/s)') plt.title('Phase Diagram: Forced Damped Pendulum (More Chaotic / Resonance)') plt.grid(True) plt.show()","title":"Scenario 4: Forced Damped Pendulum (Less Chaotic)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-5-forced-damped-pendulum-more-chaotic-resonance","text":"This scenario also involves a forced damped pendulum, but with parameters set to potentially exhibit chaotic behavior. This often occurs when the damping is relatively low and the external force is significant, especially if the frequency of the external force ( omega ) is close to the natural frequency of the pendulum (resonance). In a chaotic system, even tiny changes in initial conditions can lead to vastly different outcomes over time, and the motion is aperiodic and unpredictable in the long term. The phase diagram in a chaotic system will not settle into a simple limit cycle and can show complex, fractal-like structures (a strange attractor).","title":"Scenario 5: Forced Damped Pendulum (More Chaotic / Resonance)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task 1. Derive the Relationship To derive the relationship between the square of the orbital period ( \\( T^2 \\) ) and the cube of the orbital radius ( \\( r^3 \\) ) for circular orbits, start with the balance of forces. The gravitational force on an orbiting body of mass \\( m \\) around a central mass \\( M \\) is: \\[ F = \\frac{G M m}{r^2} \\] The centripetal force required for circular motion at velocity \\( v \\) is: \\[ F = m \\frac{v^2}{r} \\] Equating these forces, we get the following aligned equations: \\[ \\begin{align} \\frac{G M m}{r^2} &= m \\frac{v^2}{r} \\\\ \\frac{G M}{r} &= v^2 \\\\ v &= \\sqrt{\\frac{G M}{r}} \\end{align} \\] The orbital period \\( T \\) is the time to complete one orbit, so the circumference \\( 2\\pi r \\) divided by the velocity \\( v \\) : \\[ \\begin{align} T &= \\frac{2\\pi r}{v} \\\\ &= \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\\\ &= 2\\pi r \\sqrt{\\frac{r}{G M}} \\\\ &= 2\\pi \\sqrt{\\frac{r^3}{G M}} \\end{align} \\] Square both sides to obtain: \\[ \\begin{align} T^2 &= \\left(2\\pi \\sqrt{\\frac{r^3}{G M}}\\right)^2 \\\\ &= (2\\pi)^2 \\frac{r^3}{G M} \\\\ &= \\frac{4\\pi^2}{G M} r^3 \\end{align} \\] Thus, \\(T^2 \\propto r^3\\) , and plotting \\( T^2 \\) vs. \\( r^3 \\) should yield a straight line with slope \\( \\frac{4\\pi^2}{G M} \\) . Note that ChatGPT's mention of an error in showing the line as straight is incorrect; the derivation confirms the relationship is linear. 2. Discuss the Implications Kepler's Third Law allows us to calculate planetary masses and distances: - Mass of the central body : By measuring \\( T \\) and \\( r \\) of an orbiting body (e.g., a moon or planet), we can determine \\( M \\) of the central body (e.g., a planet or star). - Orbital radius : If \\( M \\) is known, we can determine \\( r \\) from \\( T \\) , useful for satellites or exoplanets. - Period prediction : Knowing \\( r \\) , we can predict \\( T \\) , aiding in mission planning for spacecraft. 3. Analyze Real-World Examples Using data from Mercury, Venus, Earth, and Mars, we verify the relationship. The chart below plots \\( T^2 \\) vs. \\( r^3 \\) for these planets, showing a straight line as expected: import numpy as np import matplotlib.pyplot as plt # Define data for the inner planets (average orbital radius in AU, orbital period in Earth years) planets = { 'Mercury': {'r': 0.387, 'T': 0.241}, 'Venus': {'r': 0.723, 'T': 0.615}, 'Earth': {'r': 1.000, 'T': 1.000}, 'Mars': {'r': 1.524, 'T': 1.881} } # Calculate r^3 and T^2 for each planet r_cubed = [p['r']**3 for p in planets.values()] T_squared = [p['T']**2 for p in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 for the planets plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='red', label='Inner Planets') # Add labels to the data points for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') # Define a range of r values for the theoretical line r_theoretical = np.linspace(min(r_cubed)**(1/3) * 0.8, max(r_cubed)**(1/3) * 1.2, 100) # Extend range slightly T_squared_theoretical = r_theoretical**3 # In AU^3 and years^2, the constant is 1 # Plot the theoretical line plt.plot(r_theoretical**3, T_squared_theoretical, color='blue', linestyle='--', label='Kepler\\'s Law (T^2 = r^3)') plt.xlabel('r^3 (AU^3)') plt.ylabel('T^2 (years^2)') plt.title('T^2 vs r^3 for Inner Planets') plt.legend() plt.grid(True) plt.show() The data points are: - Mercury: \\( T = 7.601 \\times 10^6 \\) s, \\( r = 5.791 \\times 10^{10} \\) m, \\( T^2 = 5.777 \\times 10^{13} \\) s\u00b2, \\( r^3 = 1.942 \\times 10^{32} \\) m\u00b3 - Venus: \\( T = 1.941 \\times 10^7 \\) s, \\( r = 1.082 \\times 10^{11} \\) m, \\( T^2 = 3.767 \\times 10^{14} \\) s\u00b2, \\( r^3 = 1.266 \\times 10^{33} \\) m\u00b3 - Earth: \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m, \\( T^2 = 9.960 \\times 10^{14} \\) s\u00b2, \\( r^3 = 3.347 \\times 10^{33} \\) m\u00b3 - Mars: \\( T = 5.936 \\times 10^7 \\) s, \\( r = 2.279 \\times 10^{11} \\) m, \\( T^2 = 3.524 \\times 10^{15} \\) s\u00b2, \\( r^3 = 1.184 \\times 10^{34} \\) m\u00b3 The linear relationship is evident, confirming Kepler's Third Law in the Solar System. 4. Implement a Computational Model A computational model can simulate circular orbits by using Kepler's Third Law. Below, we calculate the masses of the Sun and Earth using real data. Mass of the Sun Using Earth's orbit around the Sun ( \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m): \\[ \\begin{align} M_{\\text{Sun}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11}) (3.156 \\times 10^7)^2} \\\\ &\\approx 1.982 \\times 10^{30} \\text{ kg} \\end{align} \\] Mass of the Earth Using the Moon's orbit around Earth ( \\( T = 2.360 \\times 10^6 \\) s, \\( r = 3.844 \\times 10^8 \\) m): \\[ \\begin{align} M_{\\text{Earth}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11}) (2.360 \\times 10^6)^2} \\\\ &\\approx 6.031 \\times 10^{24} \\text{ kg} \\end{align} \\] Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of circular orbits and the relationship between orbital period and radius. A discussion on how this relationship extends to elliptical orbits and other celestial bodies. Colab Link","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derive-the-relationship","text":"To derive the relationship between the square of the orbital period ( \\( T^2 \\) ) and the cube of the orbital radius ( \\( r^3 \\) ) for circular orbits, start with the balance of forces. The gravitational force on an orbiting body of mass \\( m \\) around a central mass \\( M \\) is: \\[ F = \\frac{G M m}{r^2} \\] The centripetal force required for circular motion at velocity \\( v \\) is: \\[ F = m \\frac{v^2}{r} \\] Equating these forces, we get the following aligned equations: \\[ \\begin{align} \\frac{G M m}{r^2} &= m \\frac{v^2}{r} \\\\ \\frac{G M}{r} &= v^2 \\\\ v &= \\sqrt{\\frac{G M}{r}} \\end{align} \\] The orbital period \\( T \\) is the time to complete one orbit, so the circumference \\( 2\\pi r \\) divided by the velocity \\( v \\) : \\[ \\begin{align} T &= \\frac{2\\pi r}{v} \\\\ &= \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\\\ &= 2\\pi r \\sqrt{\\frac{r}{G M}} \\\\ &= 2\\pi \\sqrt{\\frac{r^3}{G M}} \\end{align} \\] Square both sides to obtain: \\[ \\begin{align} T^2 &= \\left(2\\pi \\sqrt{\\frac{r^3}{G M}}\\right)^2 \\\\ &= (2\\pi)^2 \\frac{r^3}{G M} \\\\ &= \\frac{4\\pi^2}{G M} r^3 \\end{align} \\] Thus, \\(T^2 \\propto r^3\\) , and plotting \\( T^2 \\) vs. \\( r^3 \\) should yield a straight line with slope \\( \\frac{4\\pi^2}{G M} \\) . Note that ChatGPT's mention of an error in showing the line as straight is incorrect; the derivation confirms the relationship is linear.","title":"1. Derive the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-discuss-the-implications","text":"Kepler's Third Law allows us to calculate planetary masses and distances: - Mass of the central body : By measuring \\( T \\) and \\( r \\) of an orbiting body (e.g., a moon or planet), we can determine \\( M \\) of the central body (e.g., a planet or star). - Orbital radius : If \\( M \\) is known, we can determine \\( r \\) from \\( T \\) , useful for satellites or exoplanets. - Period prediction : Knowing \\( r \\) , we can predict \\( T \\) , aiding in mission planning for spacecraft.","title":"2. Discuss the Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-analyze-real-world-examples","text":"Using data from Mercury, Venus, Earth, and Mars, we verify the relationship. The chart below plots \\( T^2 \\) vs. \\( r^3 \\) for these planets, showing a straight line as expected: import numpy as np import matplotlib.pyplot as plt # Define data for the inner planets (average orbital radius in AU, orbital period in Earth years) planets = { 'Mercury': {'r': 0.387, 'T': 0.241}, 'Venus': {'r': 0.723, 'T': 0.615}, 'Earth': {'r': 1.000, 'T': 1.000}, 'Mars': {'r': 1.524, 'T': 1.881} } # Calculate r^3 and T^2 for each planet r_cubed = [p['r']**3 for p in planets.values()] T_squared = [p['T']**2 for p in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 for the planets plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='red', label='Inner Planets') # Add labels to the data points for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') # Define a range of r values for the theoretical line r_theoretical = np.linspace(min(r_cubed)**(1/3) * 0.8, max(r_cubed)**(1/3) * 1.2, 100) # Extend range slightly T_squared_theoretical = r_theoretical**3 # In AU^3 and years^2, the constant is 1 # Plot the theoretical line plt.plot(r_theoretical**3, T_squared_theoretical, color='blue', linestyle='--', label='Kepler\\'s Law (T^2 = r^3)') plt.xlabel('r^3 (AU^3)') plt.ylabel('T^2 (years^2)') plt.title('T^2 vs r^3 for Inner Planets') plt.legend() plt.grid(True) plt.show() The data points are: - Mercury: \\( T = 7.601 \\times 10^6 \\) s, \\( r = 5.791 \\times 10^{10} \\) m, \\( T^2 = 5.777 \\times 10^{13} \\) s\u00b2, \\( r^3 = 1.942 \\times 10^{32} \\) m\u00b3 - Venus: \\( T = 1.941 \\times 10^7 \\) s, \\( r = 1.082 \\times 10^{11} \\) m, \\( T^2 = 3.767 \\times 10^{14} \\) s\u00b2, \\( r^3 = 1.266 \\times 10^{33} \\) m\u00b3 - Earth: \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m, \\( T^2 = 9.960 \\times 10^{14} \\) s\u00b2, \\( r^3 = 3.347 \\times 10^{33} \\) m\u00b3 - Mars: \\( T = 5.936 \\times 10^7 \\) s, \\( r = 2.279 \\times 10^{11} \\) m, \\( T^2 = 3.524 \\times 10^{15} \\) s\u00b2, \\( r^3 = 1.184 \\times 10^{34} \\) m\u00b3 The linear relationship is evident, confirming Kepler's Third Law in the Solar System.","title":"3. Analyze Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implement-a-computational-model","text":"A computational model can simulate circular orbits by using Kepler's Third Law. Below, we calculate the masses of the Sun and Earth using real data.","title":"4. Implement a Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-of-the-sun","text":"Using Earth's orbit around the Sun ( \\( T = 3.156 \\times 10^7 \\) s, \\( r = 1.496 \\times 10^{11} \\) m): \\[ \\begin{align} M_{\\text{Sun}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11}) (3.156 \\times 10^7)^2} \\\\ &\\approx 1.982 \\times 10^{30} \\text{ kg} \\end{align} \\]","title":"Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-of-the-earth","text":"Using the Moon's orbit around Earth ( \\( T = 2.360 \\times 10^6 \\) s, \\( r = 3.844 \\times 10^8 \\) m): \\[ \\begin{align} M_{\\text{Earth}} &= \\frac{4\\pi^2 r^3}{G T^2} \\\\ &= \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11}) (2.360 \\times 10^6)^2} \\\\ &\\approx 6.031 \\times 10^{24} \\text{ kg} \\end{align} \\]","title":"Mass of the Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of circular orbits and the relationship between orbital period and radius. A discussion on how this relationship extends to elliptical orbits and other celestial bodies. Colab Link","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2: Escape Velocities and Cosmic Velocities The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Solution 1. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) : This is the minimum speed needed for an object to orbit a celestial body at its surface, assuming no atmospheric drag. It is also called the circular orbital velocity. For a body of mass \\(M\\) and radius \\(R\\) , it is given by \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) , where \\(G\\) is the gravitational constant ( \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). Second Cosmic Velocity ( \\(v_2\\) ) : Known as the escape velocity, this is the minimum speed required for an object to escape the gravitational pull of a celestial body and not return. It is given by \\(v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This is the speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System) entirely, assuming it starts from the orbit of a planet like Earth. It depends on the distance from the star and the planet\u2019s orbital velocity. A simplified approximation for an object escaping the Sun from Earth's orbit is \\(v_3 \\approx \\sqrt{2} \\cdot v_{\\text{orbit}}\\) , where \\(v_{\\text{orbit}}\\) is Earth's orbital speed around the Sun. 2. Mathematical Derivations and Parameters The derivations for these velocities stem from energy conservation and gravitational physics: First Cosmic Velocity ( \\(v_1\\) ) : For a circular orbit, the centripetal force equals the gravitational force: \\(\\frac{m v_1^2}{R} = \\frac{G M m}{R^2}\\) , simplifying to \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) . Key parameters are \\(G\\) , \\(M\\) , and \\(R\\) . Second Cosmic Velocity ( \\(v_2\\) ) : To escape, the total mechanical energy must be zero: kinetic energy \\(\\frac{1}{2} m v_2^2\\) equals the potential energy \\(\\frac{G M m}{R}\\) , so \\(\\frac{1}{2} m v_2^2 = \\frac{G M m}{R}\\) , yielding \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This involves escaping the Sun\u2019s gravity from Earth\u2019s orbit. Earth\u2019s orbital speed around the Sun is \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r}}\\) , where \\(r\\) is the distance from the Sun (e.g., 1 AU for Earth). The escape velocity from the Sun at this distance is \\(\\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) . The third cosmic velocity is the additional speed needed beyond Earth\u2019s orbital speed, approximated as \\(v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) if starting from rest relative to the Sun, but adjusted for Earth\u2019s motion. Parameters affecting these velocities include the mass of the celestial body ( \\(M\\) ), its radius ( \\(R\\) ), and, for \\(v_3\\) , the distance from the star ( \\(r\\) ). Cosmic Velocities for Earth: First Cosmic Velocity (v1): 7.91 km/s (Orbital velocity just above surface) Second Cosmic Velocity (v2): 11.19 km/s (Escape velocity from Earth's surface) Escape Velocity from Sun at Earth's orbit: 42.13 km/s 3. Calculations and Visualization Let\u2019s calculate these velocities for Earth, Mars, and Jupiter using the following data: Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) . Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.390 \\times 10^6 \\, \\text{m}\\) . Jupiter : \\(M = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) . Sun (for \\(v_3\\) from Earth\u2019s orbit): \\(M_{\\text{Sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) , \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU). Python Script for Calculations import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.991e7} } sun_mass = 1.989e30 # Sun's mass (kg) earth_sun_distance = 1.496e11 # 1 AU (m) # Calculate velocities v1, v2, v3 = [], [], [] labels = [] for body, data in bodies.items(): M = data['mass'] R = data['radius'] # First cosmic velocity v1.append(np.sqrt(G * M / R) / 1000) # Convert to km/s # Second cosmic velocity v2.append(np.sqrt(2 * G * M / R) / 1000) # Convert to km/s # Third cosmic velocity (approximation from Earth's orbit around Sun) if body == 'Earth': v_sun_escape = np.sqrt(2 * G * sun_mass / earth_sun_distance) / 1000 # km/s v_orbit = np.sqrt(G * sun_mass / earth_sun_distance) / 1000 # km/s v3.append(v_sun_escape) # Simplified: total escape speed from Sun else: v3.append(None) # Only calculate v3 for Earth in this example labels.append(body) # Plotting (you can run this in a Jupyter notebook) plt.figure(figsize=(10, 6)) width = 0.25 x = np.arange(len(labels)) plt.bar(x - width, v1, width, label='First Cosmic Velocity (v1)', color='#1E90FF') plt.bar(x, v2, width, label='Second Cosmic Velocity (v2)', color='#FFD700') plt.bar(x + width, [v3[0], 0, 0], width, label='Third Cosmic Velocity (v3, Earth only)', color='#FF4500') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.show() Colab Colab Link","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#solution","text":"","title":"Solution"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"First Cosmic Velocity ( \\(v_1\\) ) : This is the minimum speed needed for an object to orbit a celestial body at its surface, assuming no atmospheric drag. It is also called the circular orbital velocity. For a body of mass \\(M\\) and radius \\(R\\) , it is given by \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) , where \\(G\\) is the gravitational constant ( \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). Second Cosmic Velocity ( \\(v_2\\) ) : Known as the escape velocity, this is the minimum speed required for an object to escape the gravitational pull of a celestial body and not return. It is given by \\(v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This is the speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System) entirely, assuming it starts from the orbit of a planet like Earth. It depends on the distance from the star and the planet\u2019s orbital velocity. A simplified approximation for an object escaping the Sun from Earth's orbit is \\(v_3 \\approx \\sqrt{2} \\cdot v_{\\text{orbit}}\\) , where \\(v_{\\text{orbit}}\\) is Earth's orbital speed around the Sun.","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-parameters","text":"The derivations for these velocities stem from energy conservation and gravitational physics: First Cosmic Velocity ( \\(v_1\\) ) : For a circular orbit, the centripetal force equals the gravitational force: \\(\\frac{m v_1^2}{R} = \\frac{G M m}{R^2}\\) , simplifying to \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) . Key parameters are \\(G\\) , \\(M\\) , and \\(R\\) . Second Cosmic Velocity ( \\(v_2\\) ) : To escape, the total mechanical energy must be zero: kinetic energy \\(\\frac{1}{2} m v_2^2\\) equals the potential energy \\(\\frac{G M m}{R}\\) , so \\(\\frac{1}{2} m v_2^2 = \\frac{G M m}{R}\\) , yielding \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) . Third Cosmic Velocity ( \\(v_3\\) ) : This involves escaping the Sun\u2019s gravity from Earth\u2019s orbit. Earth\u2019s orbital speed around the Sun is \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r}}\\) , where \\(r\\) is the distance from the Sun (e.g., 1 AU for Earth). The escape velocity from the Sun at this distance is \\(\\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) . The third cosmic velocity is the additional speed needed beyond Earth\u2019s orbital speed, approximated as \\(v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r}}\\) if starting from rest relative to the Sun, but adjusted for Earth\u2019s motion. Parameters affecting these velocities include the mass of the celestial body ( \\(M\\) ), its radius ( \\(R\\) ), and, for \\(v_3\\) , the distance from the star ( \\(r\\) ). Cosmic Velocities for Earth: First Cosmic Velocity (v1): 7.91 km/s (Orbital velocity just above surface) Second Cosmic Velocity (v2): 11.19 km/s (Escape velocity from Earth's surface) Escape Velocity from Sun at Earth's orbit: 42.13 km/s","title":"2. Mathematical Derivations and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-and-visualization","text":"Let\u2019s calculate these velocities for Earth, Mars, and Jupiter using the following data: Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) . Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.390 \\times 10^6 \\, \\text{m}\\) . Jupiter : \\(M = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) . Sun (for \\(v_3\\) from Earth\u2019s orbit): \\(M_{\\text{Sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) , \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU).","title":"3. Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script-for-calculations","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.991e7} } sun_mass = 1.989e30 # Sun's mass (kg) earth_sun_distance = 1.496e11 # 1 AU (m) # Calculate velocities v1, v2, v3 = [], [], [] labels = [] for body, data in bodies.items(): M = data['mass'] R = data['radius'] # First cosmic velocity v1.append(np.sqrt(G * M / R) / 1000) # Convert to km/s # Second cosmic velocity v2.append(np.sqrt(2 * G * M / R) / 1000) # Convert to km/s # Third cosmic velocity (approximation from Earth's orbit around Sun) if body == 'Earth': v_sun_escape = np.sqrt(2 * G * sun_mass / earth_sun_distance) / 1000 # km/s v_orbit = np.sqrt(G * sun_mass / earth_sun_distance) / 1000 # km/s v3.append(v_sun_escape) # Simplified: total escape speed from Sun else: v3.append(None) # Only calculate v3 for Earth in this example labels.append(body) # Plotting (you can run this in a Jupyter notebook) plt.figure(figsize=(10, 6)) width = 0.25 x = np.arange(len(labels)) plt.bar(x - width, v1, width, label='First Cosmic Velocity (v1)', color='#1E90FF') plt.bar(x, v2, width, label='Second Cosmic Velocity (v2)', color='#FFD700') plt.bar(x + width, [v3[0], 0, 0], width, label='Third Cosmic Velocity (v3, Earth only)', color='#FF4500') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.show()","title":"Python Script for Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Payload Trajectories Near Earth When a payload is released from a rocket near Earth, its path is governed by Newtonian gravity and initial conditions such as velocity, direction, and altitude. This document explores the types of trajectories possible\u2014elliptical, parabolic, or hyperbolic\u2014and simulates them using numerical integration. Physical Background The gravitational force acting on a payload of mass \\(m\\) due to the Earth (mass \\(M\\) ) is given by Newton\u2019s Law of Gravitation: \\[ \\vec{F}_g = - \\frac{G M m}{r^2} \\hat{r} \\] where: - \\(G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) is the gravitational constant, - \\(r\\) is the distance from the center of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the object to the Earth. The motion of the payload can be determined by solving Newton's second law: \\[ \\vec{a} = \\frac{\\vec{F}_g}{m} = - \\frac{G M}{r^2} \\hat{r} \\] Initial Conditions Altitude : 800 km above Earth's surface Earth radius : \\(R_E = 6371\\) km Initial position : \\(\\vec{r}_0 = (R_E + 800, 0)\\) km Initial velocities : 5 to 13 km/s in the tangential (positive y) direction Trajectory Types Elliptical orbit : \\(v < v_{\\text{escape}}\\) Parabolic escape : \\(v = v_{\\text{escape}}\\) Hyperbolic escape : \\(v > v_{\\text{escape}}\\) Escape velocity from a distance \\(r\\) is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} $$ Python Simulation The following Python code numerically integrates the motion using the Runge-Kutta method and plots the trajectory for various initial velocities. Earth is represented as a blue circle on the plot. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # === Constants === G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth mass (kg) R_earth = 6371e3 # Earth radius (m) mu = G * M # Gravitational parameter (m^3 s^-2) # === Launch Parameters === altitude = 800e3 # Altitude above Earth's surface (m) r0 = R_earth + altitude # Initial distance from Earth's center (m) x0, y0 = r0, 0 # Launch from x-axis v0_list = np.arange(5, 13.5, 0.5) * 1e3 # Speeds: 5 to 13 km/s # Convert for plotting R_earth_km = R_earth / 1e3 r0_km = r0 / 1e3 # === Gravity equations === def equations(state, t): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # === Time array === t_max = 30000 t = np.linspace(0, t_max, 10000) # === Plot setup === fig, ax = plt.subplots(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth_km, color='blue', alpha=0.5, label='Earth') ax.add_patch(earth) ax.plot(0, 0, 'y*', label='Earth center') colors = plt.cm.viridis(np.linspace(0, 1, len(v0_list))) # === Simulate and plot trajectories === for i, v0 in enumerate(v0_list): state0 = [x0, y0, 0, v0] # Launch tangentially (along +y) solution = odeint(equations, state0, t) x_m = solution[:, 0] y_m = solution[:, 1] r_m = np.sqrt(x_m**2 + y_m**2) # If the projectile ever enters the Earth, skip the whole trajectory if np.any(r_m < R_earth): continue # This one hit Earth, skip # Otherwise, plot the full clean trajectory x_km = x_m / 1e3 y_km = y_m / 1e3 ax.plot(x_km, y_km, color=colors[i], label=f'v\u2080 = {v0/1e3:.1f} km/s') # === Final plot formatting === ax.set_xlim(-3 * r0_km, 3 * r0_km) ax.set_ylim(-3 * r0_km, 3 * r0_km) ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_title('Clean Orbital / Escape Trajectories (No Earth Impact)') ax.set_aspect('equal') ax.grid(True) ax.legend(fontsize=8, loc='upper right') plt.tight_layout() plt.show() Colab Colab Link","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#payload-trajectories-near-earth","text":"When a payload is released from a rocket near Earth, its path is governed by Newtonian gravity and initial conditions such as velocity, direction, and altitude. This document explores the types of trajectories possible\u2014elliptical, parabolic, or hyperbolic\u2014and simulates them using numerical integration.","title":"Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-background","text":"The gravitational force acting on a payload of mass \\(m\\) due to the Earth (mass \\(M\\) ) is given by Newton\u2019s Law of Gravitation: \\[ \\vec{F}_g = - \\frac{G M m}{r^2} \\hat{r} \\] where: - \\(G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) is the gravitational constant, - \\(r\\) is the distance from the center of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the object to the Earth. The motion of the payload can be determined by solving Newton's second law: \\[ \\vec{a} = \\frac{\\vec{F}_g}{m} = - \\frac{G M}{r^2} \\hat{r} \\]","title":"Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Altitude : 800 km above Earth's surface Earth radius : \\(R_E = 6371\\) km Initial position : \\(\\vec{r}_0 = (R_E + 800, 0)\\) km Initial velocities : 5 to 13 km/s in the tangential (positive y) direction","title":"Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types","text":"Elliptical orbit : \\(v < v_{\\text{escape}}\\) Parabolic escape : \\(v = v_{\\text{escape}}\\) Hyperbolic escape : \\(v > v_{\\text{escape}}\\) Escape velocity from a distance \\(r\\) is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} $$","title":"Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"The following Python code numerically integrates the motion using the Runge-Kutta method and plots the trajectory for various initial velocities. Earth is represented as a blue circle on the plot. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # === Constants === G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth mass (kg) R_earth = 6371e3 # Earth radius (m) mu = G * M # Gravitational parameter (m^3 s^-2) # === Launch Parameters === altitude = 800e3 # Altitude above Earth's surface (m) r0 = R_earth + altitude # Initial distance from Earth's center (m) x0, y0 = r0, 0 # Launch from x-axis v0_list = np.arange(5, 13.5, 0.5) * 1e3 # Speeds: 5 to 13 km/s # Convert for plotting R_earth_km = R_earth / 1e3 r0_km = r0 / 1e3 # === Gravity equations === def equations(state, t): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # === Time array === t_max = 30000 t = np.linspace(0, t_max, 10000) # === Plot setup === fig, ax = plt.subplots(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth_km, color='blue', alpha=0.5, label='Earth') ax.add_patch(earth) ax.plot(0, 0, 'y*', label='Earth center') colors = plt.cm.viridis(np.linspace(0, 1, len(v0_list))) # === Simulate and plot trajectories === for i, v0 in enumerate(v0_list): state0 = [x0, y0, 0, v0] # Launch tangentially (along +y) solution = odeint(equations, state0, t) x_m = solution[:, 0] y_m = solution[:, 1] r_m = np.sqrt(x_m**2 + y_m**2) # If the projectile ever enters the Earth, skip the whole trajectory if np.any(r_m < R_earth): continue # This one hit Earth, skip # Otherwise, plot the full clean trajectory x_km = x_m / 1e3 y_km = y_m / 1e3 ax.plot(x_km, y_km, color=colors[i], label=f'v\u2080 = {v0/1e3:.1f} km/s') # === Final plot formatting === ax.set_xlim(-3 * r0_km, 3 * r0_km) ax.set_ylim(-3 * r0_km, 3 * r0_km) ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_title('Clean Orbital / Escape Trajectories (No Earth Impact)') ax.set_aspect('equal') ax.grid(True) ax.legend(fontsize=8, loc='upper right') plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Solution Step 1: Select a Regular Polygon Let's choose a square as the regular polygon, with vertices at coordinates \\((0,0)\\) , \\((1,0)\\) , \\((1,1)\\) , and \\((0,1)\\) . Each vertex will have a point source emitting waves. Step 2: Position the Sources The sources are placed at the vertices of the square: - Source 1: \\((0,0)\\) - Source 2: \\((1,0)\\) - Source 3: \\((1,1)\\) - Source 4: \\((0,1)\\) Step 3: Wave Equations Each source emits a wave with amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , wave number \\(k = \\frac{2\\pi}{\\lambda}\\) , and angular frequency \\(\\omega = 2\\pi f\\) . The wave from a source at \\((x_i, y_i)\\) to a point \\((x, y)\\) at time \\(t\\) is given by: Distance from source to point: \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) Wave equation: \\(\\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi)\\) Since all sources have the same phase, we set \\(\\phi = 0\\) . Thus, for each source: - Source 1 at \\((0,0)\\) : \\(r_1 = \\sqrt{x^2 + y^2}\\) , \\(\\eta_1(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t)\\) - Source 2 at \\((1,0)\\) : \\(r_2 = \\sqrt{(x-1)^2 + y^2}\\) , \\(\\eta_2(x, y, t) = \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t)\\) - Source 3 at \\((1,1)\\) : \\(r_3 = \\sqrt{(x-1)^2 + (y-1)^2}\\) , \\(\\eta_3(x, y, t) = \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t)\\) - Source 4 at \\((0,1)\\) : \\(r_4 = \\sqrt{x^2 + (y-1)^2}\\) , \\(\\eta_4(x, y, t) = \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\) Step 4: Superposition of Waves The total displacement at point \\((x, y)\\) and time \\(t\\) is the sum of the waves from all sources: \\(\\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) + \\eta_3(x, y, t) + \\eta_4(x, y, t)\\) So, \\(\\eta_{\\text{sum}}(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t) + \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t) + \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t) + \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\) Step 5: Analyze Interference Patterns Constructive Interference : Occurs when the waves are in phase, i.e., the path difference \\(r_i - r_j\\) is a multiple of \\(\\lambda\\) . For example, at the center of the square \\((0.5, 0.5)\\) , calculate \\(r_i\\) from each source to check for constructive interference. Destructive Interference : Occurs when the waves are out of phase by \\(\\pi\\) , i.e., the path difference is an odd multiple of \\(\\frac{\\lambda}{2}\\) . This can be observed along lines where waves cancel out. Step 6: Visualization To visualize the interference patterns, use Python with Matplotlib to plot the total displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) over a 2D grid at a fixed time \\(t\\) . A heatmap or contour plot can illustrate regions of constructive and destructive interference effectively. import numpy as np import matplotlib.pyplot as plt import plotly.graph_objects as go from matplotlib import animation from IPython.display import HTML def create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed): \"\"\"Creates a wave from a single source.\"\"\" distance = np.sqrt((x - source_x)**2 + (y - source_y)**2) wave = amplitude * np.sin(2 * np.pi * (distance / wavelength - time * speed / wavelength)) return wave # Define parameters grid_size = 100 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) source_x, source_y = 0, 0 amplitude = 1 wavelength = 1 speed = 1 time = 0 # Generate wave data wave_data = create_wave(X, Y, source_x, source_y, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(wave_data, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Wave from One Source (Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=wave_data, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Wave from One Source (3D)', scene = dict( xaxis_title='X', yaxis_title='Y', zaxis_title='Amplitude')) fig.show() def create_interference(x, y, sources, amplitude, wavelength, time, speed): \"\"\"Creates interference pattern from multiple sources.\"\"\" total_wave = np.zeros_like(x) for source_x, source_y in sources: total_wave += create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed) return total_wave # Define parameters for two sources sources_two = [( -2, 0), (2, 0)] # Source positions time = 0 # Generate interference data interference_data_two = create_interference(X, Y, sources_two, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(interference_data_two, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Interference Pattern (Two Sources - Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=interference_data_two, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Interference Pattern (Two Sources - 3D)', scene = dict( xaxis_title='X', yaxis_title='Y', Colab Colab Link","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-solution","text":"","title":"Wave Interference Solution"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-select-a-regular-polygon","text":"Let's choose a square as the regular polygon, with vertices at coordinates \\((0,0)\\) , \\((1,0)\\) , \\((1,1)\\) , and \\((0,1)\\) . Each vertex will have a point source emitting waves.","title":"Step 1: Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-position-the-sources","text":"The sources are placed at the vertices of the square: - Source 1: \\((0,0)\\) - Source 2: \\((1,0)\\) - Source 3: \\((1,1)\\) - Source 4: \\((0,1)\\)","title":"Step 2: Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-wave-equations","text":"Each source emits a wave with amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , wave number \\(k = \\frac{2\\pi}{\\lambda}\\) , and angular frequency \\(\\omega = 2\\pi f\\) . The wave from a source at \\((x_i, y_i)\\) to a point \\((x, y)\\) at time \\(t\\) is given by: Distance from source to point: \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) Wave equation: \\(\\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi)\\) Since all sources have the same phase, we set \\(\\phi = 0\\) . Thus, for each source: - Source 1 at \\((0,0)\\) : \\(r_1 = \\sqrt{x^2 + y^2}\\) , \\(\\eta_1(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t)\\) - Source 2 at \\((1,0)\\) : \\(r_2 = \\sqrt{(x-1)^2 + y^2}\\) , \\(\\eta_2(x, y, t) = \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t)\\) - Source 3 at \\((1,1)\\) : \\(r_3 = \\sqrt{(x-1)^2 + (y-1)^2}\\) , \\(\\eta_3(x, y, t) = \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t)\\) - Source 4 at \\((0,1)\\) : \\(r_4 = \\sqrt{x^2 + (y-1)^2}\\) , \\(\\eta_4(x, y, t) = \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\)","title":"Step 3: Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-superposition-of-waves","text":"The total displacement at point \\((x, y)\\) and time \\(t\\) is the sum of the waves from all sources: \\(\\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) + \\eta_3(x, y, t) + \\eta_4(x, y, t)\\) So, \\(\\eta_{\\text{sum}}(x, y, t) = \\frac{A}{\\sqrt{r_1}} \\cos(k r_1 - \\omega t) + \\frac{A}{\\sqrt{r_2}} \\cos(k r_2 - \\omega t) + \\frac{A}{\\sqrt{r_3}} \\cos(k r_3 - \\omega t) + \\frac{A}{\\sqrt{r_4}} \\cos(k r_4 - \\omega t)\\)","title":"Step 4: Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-5-analyze-interference-patterns","text":"Constructive Interference : Occurs when the waves are in phase, i.e., the path difference \\(r_i - r_j\\) is a multiple of \\(\\lambda\\) . For example, at the center of the square \\((0.5, 0.5)\\) , calculate \\(r_i\\) from each source to check for constructive interference. Destructive Interference : Occurs when the waves are out of phase by \\(\\pi\\) , i.e., the path difference is an odd multiple of \\(\\frac{\\lambda}{2}\\) . This can be observed along lines where waves cancel out.","title":"Step 5: Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-6-visualization","text":"To visualize the interference patterns, use Python with Matplotlib to plot the total displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) over a 2D grid at a fixed time \\(t\\) . A heatmap or contour plot can illustrate regions of constructive and destructive interference effectively. import numpy as np import matplotlib.pyplot as plt import plotly.graph_objects as go from matplotlib import animation from IPython.display import HTML def create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed): \"\"\"Creates a wave from a single source.\"\"\" distance = np.sqrt((x - source_x)**2 + (y - source_y)**2) wave = amplitude * np.sin(2 * np.pi * (distance / wavelength - time * speed / wavelength)) return wave # Define parameters grid_size = 100 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) source_x, source_y = 0, 0 amplitude = 1 wavelength = 1 speed = 1 time = 0 # Generate wave data wave_data = create_wave(X, Y, source_x, source_y, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(wave_data, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Wave from One Source (Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=wave_data, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Wave from One Source (3D)', scene = dict( xaxis_title='X', yaxis_title='Y', zaxis_title='Amplitude')) fig.show() def create_interference(x, y, sources, amplitude, wavelength, time, speed): \"\"\"Creates interference pattern from multiple sources.\"\"\" total_wave = np.zeros_like(x) for source_x, source_y in sources: total_wave += create_wave(x, y, source_x, source_y, amplitude, wavelength, time, speed) return total_wave # Define parameters for two sources sources_two = [( -2, 0), (2, 0)] # Source positions time = 0 # Generate interference data interference_data_two = create_interference(X, Y, sources_two, amplitude, wavelength, time, speed) # Plotting (Heatmap) plt.figure(figsize=(6, 6)) plt.imshow(interference_data_two, extent=[-5, 5, -5, 5], origin='lower', cmap='viridis') plt.title('Interference Pattern (Two Sources - Heatmap)') plt.xlabel('X') plt.ylabel('Y') plt.colorbar(label='Amplitude') plt.show() # Plotting (3D) fig = go.Figure(data=[go.Surface(z=interference_data_two, x=x, y=y, colorscale='viridis')]) fig.update_layout(title='Interference Pattern (Two Sources - 3D)', scene = dict( xaxis_title='X', yaxis_title='Y',","title":"Step 6: Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism: Lorentz Force Simulations Introduction The Lorentz force describes the force exerted on a charged particle moving through electric and magnetic fields. It is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\( \\vec{F} \\) is the force on the particle (in newtons, N), - \\( q \\) is the electric charge of the particle (in coulombs, C), - \\( \\vec{E} \\) is the electric field (in volts per meter, V/m), - \\( \\vec{v} \\) is the velocity of the particle (in meters per second, m/s), - \\( \\vec{B} \\) is the magnetic field (in teslas, T). This force is fundamental in understanding the motion of charged particles in electromagnetic fields, leading to various trajectory patterns depending on the initial conditions and field configurations. Simulation Setup We will simulate the motion of a charged particle under different electromagnetic field configurations using Python. The simulations will cover: Circular Motion : Particle moving perpendicular to a uniform magnetic field. Spiral Motion : Particle with an initial velocity component along the magnetic field. E\u00d7B Drift : Particle in crossed electric and magnetic fields. Parameters Charge : \\( q = 1\\, \\text{C} \\) Mass : \\( m = 1\\, \\text{g} = 0.001\\, \\text{kg} \\) Time Span : \\( t \\in [0, 0.05]\\, \\text{s} \\) Time Steps : 1000 Python Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import solve_ivp # Constants q = 1.0 # charge [C] m = 0.001 # mass [kg] B = np.array([0, 0, 1]) # Magnetic field [T] E = np.array([0, 0, 0]) # Default: no electric field # Lorentz Force Equation def lorentz_force(t, state, E, B): r = state[0:3] v = state[3:6] a = (q/m) * (E + np.cross(v, B)) return np.concatenate((v, a)) # Plotting function def plot_trajectory(sol, title='Trajectory'): fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(sol.y[0], sol.y[1], sol.y[2]) ax.set_title(title) ax.set_xlabel('x [m]') ax.set_ylabel('y [m]') ax.set_zlabel('z [m]') ax.grid(True) plt.show() # Time settings t_span = (0, 0.05) t_eval = np.linspace(*t_span, 1000) ### 1. Circular Trajectory (vx \u2260 0, vy = vz = 0), B field only ### v0 = np.array([0, 1e3, 0]) # Initial velocity r0 = np.array([0, 0, 0]) # Initial position state0 = np.concatenate((r0, v0)) sol1 = solve_ivp(lorentz_force, t_span, state0, t_eval=t_eval, args=(E, B)) plot_trajectory(sol1, title='Circular Motion in Magnetic Field') ### 2. Spiral Trajectory (add vz) ### v0 = np.array([0, 1e3, 500]) # z-component causes spiral state0 = np.concatenate((r0, v0)) sol2 = solve_ivp(lorentz_force, t_span, state0, t_eval=t_eval, args=(E, B)) plot_trajectory(sol2, title='Spiral Motion in Magnetic Field') ### 3. Drift in E x B Field ### E = np.array([1000, 0, 0]) # Electric field in x B = np.array([0, 0, 1]) # Magnetic field in z v0 = np.array([0, 1e3, 0]) # Perpendicular velocity state0 = np.concatenate((r0, v0)) sol3 = solve_ivp(lorentz_force, t_span, state0, t_eval=t_eval, args=(E, B)) plot_trajectory(sol3, title='E \u00d7 B Drift') Colab Colab Link","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulations","text":"","title":"Electromagnetism: Lorentz Force Simulations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force describes the force exerted on a charged particle moving through electric and magnetic fields. It is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\( \\vec{F} \\) is the force on the particle (in newtons, N), - \\( q \\) is the electric charge of the particle (in coulombs, C), - \\( \\vec{E} \\) is the electric field (in volts per meter, V/m), - \\( \\vec{v} \\) is the velocity of the particle (in meters per second, m/s), - \\( \\vec{B} \\) is the magnetic field (in teslas, T). This force is fundamental in understanding the motion of charged particles in electromagnetic fields, leading to various trajectory patterns depending on the initial conditions and field configurations.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-setup","text":"We will simulate the motion of a charged particle under different electromagnetic field configurations using Python. The simulations will cover: Circular Motion : Particle moving perpendicular to a uniform magnetic field. Spiral Motion : Particle with an initial velocity component along the magnetic field. E\u00d7B Drift : Particle in crossed electric and magnetic fields.","title":"Simulation Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Charge : \\( q = 1\\, \\text{C} \\) Mass : \\( m = 1\\, \\text{g} = 0.001\\, \\text{kg} \\) Time Span : \\( t \\in [0, 0.05]\\, \\text{s} \\) Time Steps : 1000","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import solve_ivp # Constants q = 1.0 # charge [C] m = 0.001 # mass [kg] B = np.array([0, 0, 1]) # Magnetic field [T] E = np.array([0, 0, 0]) # Default: no electric field # Lorentz Force Equation def lorentz_force(t, state, E, B): r = state[0:3] v = state[3:6] a = (q/m) * (E + np.cross(v, B)) return np.concatenate((v, a)) # Plotting function def plot_trajectory(sol, title='Trajectory'): fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(sol.y[0], sol.y[1], sol.y[2]) ax.set_title(title) ax.set_xlabel('x [m]') ax.set_ylabel('y [m]') ax.set_zlabel('z [m]') ax.grid(True) plt.show() # Time settings t_span = (0, 0.05) t_eval = np.linspace(*t_span, 1000) ### 1. Circular Trajectory (vx \u2260 0, vy = vz = 0), B field only ### v0 = np.array([0, 1e3, 0]) # Initial velocity r0 = np.array([0, 0, 0]) # Initial position state0 = np.concatenate((r0, v0)) sol1 = solve_ivp(lorentz_force, t_span, state0, t_eval=t_eval, args=(E, B)) plot_trajectory(sol1, title='Circular Motion in Magnetic Field') ### 2. Spiral Trajectory (add vz) ### v0 = np.array([0, 1e3, 500]) # z-component causes spiral state0 = np.concatenate((r0, v0)) sol2 = solve_ivp(lorentz_force, t_span, state0, t_eval=t_eval, args=(E, B)) plot_trajectory(sol2, title='Spiral Motion in Magnetic Field') ### 3. Drift in E x B Field ### E = np.array([1000, 0, 0]) # Electric field in x B = np.array([0, 0, 1]) # Magnetic field in z v0 = np.array([0, 1e3, 0]) # Perpendicular velocity state0 = np.concatenate((r0, v0)) sol3 = solve_ivp(lorentz_force, t_span, state0, t_eval=t_eval, args=(E, B)) plot_trajectory(sol3, title='E \u00d7 B Drift') Colab Colab Link","title":"Python Code"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \ud83d\udd0c Circuit Analysis Exercise: [Exercise Title] Objective Briefly describe the goal of the exercise. For example: - Analyze the behavior of an RC circuit over time. - Determine the current and voltage across components in an RLC circuit. Problem Statement Provide a detailed description of the circuit problem, including: - The type of circuit (e.g., series, parallel, RLC). - Given values (e.g., resistance, capacitance, inductance, voltage sources). - What needs to be calculated or analyzed. Circuit Diagram Include a schematic of the circuit. You can use tools like Circuitikz for LaTeX or embed an image: Theoretical Background Discuss the relevant theories and formulas: - Ohm's Law - Kirchhoff's Laws - Differential equations governing the circuit behavior Calculations Show step-by-step calculations: 1. Apply Kirchhoff's Voltage and Current Laws. 2. Solve the differential equations. 3. Calculate the desired quantities (e.g., current, voltage, impedance). Simulation If applicable, include a simulation of the circuit using Python: ```python import numpy as np import matplotlib.pyplot as plt Define parameters R = 1000 # Resistance in ohms C = 1e-6 # Capacitance in farads V0 = 5 # Initial voltage in volts Time array t = np.linspace(0, 0.01, 1000) Voltage across capacitor over time in an RC charging circuit Vc = V0 * (1 - np.exp(-t / (R * C))) Plotting plt.plot(t, Vc) plt.title('Voltage Across Capacitor Over Time') plt.xlabel('Time (s)') plt.ylabel('Voltage (V)') plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-analysis-exercise-exercise-title","text":"","title":"\ud83d\udd0c Circuit Analysis Exercise: [Exercise Title]"},{"location":"1%20Physics/5%20Circuits/Problem_1/#objective","text":"Briefly describe the goal of the exercise. For example: - Analyze the behavior of an RC circuit over time. - Determine the current and voltage across components in an RLC circuit.","title":"Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-statement","text":"Provide a detailed description of the circuit problem, including: - The type of circuit (e.g., series, parallel, RLC). - Given values (e.g., resistance, capacitance, inductance, voltage sources). - What needs to be calculated or analyzed.","title":"Problem Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-diagram","text":"Include a schematic of the circuit. You can use tools like Circuitikz for LaTeX or embed an image:","title":"Circuit Diagram"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-background","text":"Discuss the relevant theories and formulas: - Ohm's Law - Kirchhoff's Laws - Differential equations governing the circuit behavior","title":"Theoretical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#calculations","text":"Show step-by-step calculations: 1. Apply Kirchhoff's Voltage and Current Laws. 2. Solve the differential equations. 3. Calculate the desired quantities (e.g., current, voltage, impedance).","title":"Calculations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simulation","text":"If applicable, include a simulation of the circuit using Python: ```python import numpy as np import matplotlib.pyplot as plt","title":"Simulation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#define-parameters","text":"R = 1000 # Resistance in ohms C = 1e-6 # Capacitance in farads V0 = 5 # Initial voltage in volts","title":"Define parameters"},{"location":"1%20Physics/5%20Circuits/Problem_1/#time-array","text":"t = np.linspace(0, 0.01, 1000)","title":"Time array"},{"location":"1%20Physics/5%20Circuits/Problem_1/#voltage-across-capacitor-over-time-in-an-rc-charging-circuit","text":"Vc = V0 * (1 - np.exp(-t / (R * C)))","title":"Voltage across capacitor over time in an RC charging circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#plotting","text":"plt.plot(t, Vc) plt.title('Voltage Across Capacitor Over Time') plt.xlabel('Time (s)') plt.ylabel('Voltage (V)') plt.grid(True) plt.show()","title":"Plotting"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem (CLT) Through Simulation Objective To understand and visualize how the Central Limit Theorem (CLT) works in practice using simulation techniques on different types of population distributions. What is the Central Limit Theorem? The Central Limit Theorem (CLT) is a fundamental theorem in probability and statistics. It states: If you take sufficiently large random samples from any population with a finite mean ( \\(\\mu\\) ) and finite variance ( \\(\\sigma^2\\) ), the distribution of the sample means will approach a normal distribution , regardless of the shape of the population distribution. Mathematical Formulation Let \\(X_1, X_2, \\dots, X_n\\) be independent and identically distributed random variables with: Mean: \\(\\mu\\) Variance: \\(\\sigma^2\\) Then the sample mean : \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] approaches a normal distribution: \\[ \\bar{X}_n \\sim \\mathcal{N} \\left( \\mu, \\frac{\\sigma^2}{n} \\right) \\] as \\(n \\rightarrow \\infty\\) . Distributions Used in This Simulation We explore the CLT using three distinct population distributions: Distribution Type Description Shape Uniform Evenly distributed between [0, 1] Symmetric Exponential Decaying probability, positive values only Skewed (Right) Binomial Discrete counts of successes in trials Varies (Symmetric if \\(p=0.5\\) ) Uniform Distribution Exponential Distribution Binomial Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set style for the plots sns.set(style=\"whitegrid\") def simulate_sample_means(distribution_func, sample_sizes, num_samples=10000): \"\"\" Simulates sample means for different sample sizes. Parameters: distribution_func: function that generates samples (e.g., np.random.uniform) sample_sizes: list of sample sizes to test num_samples: how many times to repeat sampling Returns: Dictionary mapping sample_size -> list of sample means \"\"\" results = {} for n in sample_sizes: sample_means = [] for _ in range(num_samples): # Generate a sample from the specified distribution sample = distribution_func(size=n) # Calculate the mean of the sample sample_mean = np.mean(sample) # Store the sample mean sample_means.append(sample_mean) results[n] = sample_means return results # Define the population distribution: Uniform between [0, 10] def generate_uniform(size): return np.random.uniform(0, 10, size=size) # Define the sample sizes to simulate sample_sizes = [5, 10, 30, 50] # Simulate sample means for the uniform distribution uniform_data = simulate_sample_means(generate_uniform, sample_sizes) # Create a figure and subplots to display the histograms fig, axes = plt.subplots(2, 2, figsize=(12, 8)) # Plot histograms of the sample means for each sample size for ax, n in zip(axes.flat, sample_sizes): sns.histplot(uniform_data[n], ax=ax, kde=True, stat=\"density\", bins=30) ax.set_title(f\"Uniform - Sample Size {n}\") # Adjust layout for better spacing plt.tight_layout() # Display the plot plt.show() Simulation Process For each population distribution, we follow this procedure: Generate a large population of size \\(N = 100,\\!000\\) . Sample multiple times from this population using sample sizes: \\(n = 5, 10, 30, 50\\) Repeat each sampling 1000 times to create a distribution of sample means. Plot histograms of these sample means to observe the distribution shape. Compare results across sample sizes to see convergence to normality. What We Expect to Observe For small sample sizes , the distribution of sample means may resemble the shape of the population. As the sample size increases , the distribution of sample means becomes more bell-shaped and symmetric . The spread (standard deviation) of the sample mean shrinks as sample size increases: \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] Key Definitions Term Meaning Population The entire dataset from which samples are drawn Sample A subset of the population Sample Mean The average value of a sample Sampling Distribution Distribution of sample means over many samples of the same size Standard Error Standard deviation of the sample mean, \\(\\sigma / \\sqrt{n}\\) Why CLT Is So Important Foundational for inferential statistics : It allows us to use sample statistics to infer population parameters. Enables confidence intervals and hypothesis testing . Provides justification for using the normal distribution in many practical applications, even when data isn't normal. Real-World Applications Manufacturing & Quality Control Monitor average product measurements (e.g., bolt diameter) to detect process issues. Business Analytics Use sample survey data to estimate market preferences. Finance Model portfolio returns \u2014 CLT helps justify assumptions of normality in asset returns. Healthcare Analyze average response times or treatment outcomes from clinical trials. Summary The CLT shows how random variation averages out over many samples. Even for non-normal populations , the mean of many samples becomes normal . This allows reliable estimation of population parameters using normal-based techniques. Colab https://colab.research.google.com/drive/1zb1_0HUP0-2ykWkjjA-NkAFgA_OBmLtH?usp=sharing","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-clt-through-simulation","text":"","title":"Exploring the Central Limit Theorem (CLT) Through Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"To understand and visualize how the Central Limit Theorem (CLT) works in practice using simulation techniques on different types of population distributions.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-is-the-central-limit-theorem","text":"The Central Limit Theorem (CLT) is a fundamental theorem in probability and statistics. It states: If you take sufficiently large random samples from any population with a finite mean ( \\(\\mu\\) ) and finite variance ( \\(\\sigma^2\\) ), the distribution of the sample means will approach a normal distribution , regardless of the shape of the population distribution.","title":"What is the Central Limit Theorem?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#mathematical-formulation","text":"Let \\(X_1, X_2, \\dots, X_n\\) be independent and identically distributed random variables with: Mean: \\(\\mu\\) Variance: \\(\\sigma^2\\) Then the sample mean : \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] approaches a normal distribution: \\[ \\bar{X}_n \\sim \\mathcal{N} \\left( \\mu, \\frac{\\sigma^2}{n} \\right) \\] as \\(n \\rightarrow \\infty\\) .","title":"Mathematical Formulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#distributions-used-in-this-simulation","text":"We explore the CLT using three distinct population distributions: Distribution Type Description Shape Uniform Evenly distributed between [0, 1] Symmetric Exponential Decaying probability, positive values only Skewed (Right) Binomial Discrete counts of successes in trials Varies (Symmetric if \\(p=0.5\\) )","title":"Distributions Used in This Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#uniform-distribution","text":"","title":"Uniform Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exponential-distribution","text":"","title":"Exponential Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#binomial-distribution","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set style for the plots sns.set(style=\"whitegrid\") def simulate_sample_means(distribution_func, sample_sizes, num_samples=10000): \"\"\" Simulates sample means for different sample sizes. Parameters: distribution_func: function that generates samples (e.g., np.random.uniform) sample_sizes: list of sample sizes to test num_samples: how many times to repeat sampling Returns: Dictionary mapping sample_size -> list of sample means \"\"\" results = {} for n in sample_sizes: sample_means = [] for _ in range(num_samples): # Generate a sample from the specified distribution sample = distribution_func(size=n) # Calculate the mean of the sample sample_mean = np.mean(sample) # Store the sample mean sample_means.append(sample_mean) results[n] = sample_means return results # Define the population distribution: Uniform between [0, 10] def generate_uniform(size): return np.random.uniform(0, 10, size=size) # Define the sample sizes to simulate sample_sizes = [5, 10, 30, 50] # Simulate sample means for the uniform distribution uniform_data = simulate_sample_means(generate_uniform, sample_sizes) # Create a figure and subplots to display the histograms fig, axes = plt.subplots(2, 2, figsize=(12, 8)) # Plot histograms of the sample means for each sample size for ax, n in zip(axes.flat, sample_sizes): sns.histplot(uniform_data[n], ax=ax, kde=True, stat=\"density\", bins=30) ax.set_title(f\"Uniform - Sample Size {n}\") # Adjust layout for better spacing plt.tight_layout() # Display the plot plt.show()","title":"Binomial Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-process","text":"For each population distribution, we follow this procedure: Generate a large population of size \\(N = 100,\\!000\\) . Sample multiple times from this population using sample sizes: \\(n = 5, 10, 30, 50\\) Repeat each sampling 1000 times to create a distribution of sample means. Plot histograms of these sample means to observe the distribution shape. Compare results across sample sizes to see convergence to normality.","title":"Simulation Process"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-we-expect-to-observe","text":"For small sample sizes , the distribution of sample means may resemble the shape of the population. As the sample size increases , the distribution of sample means becomes more bell-shaped and symmetric . The spread (standard deviation) of the sample mean shrinks as sample size increases: \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\]","title":"What We Expect to Observe"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-definitions","text":"Term Meaning Population The entire dataset from which samples are drawn Sample A subset of the population Sample Mean The average value of a sample Sampling Distribution Distribution of sample means over many samples of the same size Standard Error Standard deviation of the sample mean, \\(\\sigma / \\sqrt{n}\\)","title":"Key Definitions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#why-clt-is-so-important","text":"Foundational for inferential statistics : It allows us to use sample statistics to infer population parameters. Enables confidence intervals and hypothesis testing . Provides justification for using the normal distribution in many practical applications, even when data isn't normal.","title":"Why CLT Is So Important"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications","text":"","title":"Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#manufacturing-quality-control","text":"Monitor average product measurements (e.g., bolt diameter) to detect process issues.","title":"Manufacturing &amp; Quality Control"},{"location":"1%20Physics/6%20Statistics/Problem_1/#business-analytics","text":"Use sample survey data to estimate market preferences.","title":"Business Analytics"},{"location":"1%20Physics/6%20Statistics/Problem_1/#finance","text":"Model portfolio returns \u2014 CLT helps justify assumptions of normality in asset returns.","title":"Finance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#healthcare","text":"Analyze average response times or treatment outcomes from clinical trials.","title":"Healthcare"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"The CLT shows how random variation averages out over many samples. Even for non-normal populations , the mean of many samples becomes normal . This allows reliable estimation of population parameters using normal-based techniques.","title":"Summary"},{"location":"1%20Physics/6%20Statistics/Problem_1/#colab","text":"https://colab.research.google.com/drive/1zb1_0HUP0-2ykWkjjA-NkAFgA_OBmLtH?usp=sharing","title":"Colab"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One elegant and visual application is the estimation of \u03c0. By simulating random processes like dart throws or needle drops, we can connect geometry , probability , and numerical methods into a hands-on approach that deepens our understanding of how randomness can be harnessed to estimate complex values like \u03c0. PART 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation We consider a unit circle (radius = 1) inscribed inside a square of side length 2. Area of the circle: \\(A_{\\text{circle}} = \\pi r^2 = \\pi\\) Area of the square: \\(A_{\\text{square}} = (2r)^2 = 4\\) Now, randomly generate points inside the square. The probability that a point falls inside the circle is proportional to the area: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] So, we estimate \u03c0 as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} \\] 2. Simulation Steps Generate \\(N\\) random points \\((x, y)\\) in the square \\([0, 1] \\times [0, 1]\\) Count how many satisfy: \\(x^2 + y^2 \\leq 1\\) Estimate \u03c0 using the formula above 3. Visualization Plot all generated points Use blue for points inside the circle Use red for points outside This visualizes how the proportion relates to \u03c0. 4. Analysis As \\(N\\) increases: The estimate becomes more accurate. The error decreases proportionally to \\(1/\\sqrt{N}\\) . Plotting \u03c0 estimates against number of points shows convergence. PART 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation Buffon's Needle is a classic probability experiment: A floor is marked with parallel lines a distance \\(d\\) apart. A needle of length \\(l \\leq d\\) is dropped randomly. We calculate the probability \\(P\\) that the needle crosses a line. The probability of crossing is: \\[ P = \\frac{2l}{\\pi d} \\] Rearranging gives an estimator for \u03c0: \\[ \\pi \\approx \\frac{2lN}{dC} \\] Where: \\(N\\) = number of needle drops \\(C\\) = number of times the needle crosses a line 2. Simulation Steps Drop \\(N\\) needles: Random center position from line: \\(x \\in [0, d/2]\\) Random angle: \\(\\theta \\in [0, \\pi/2]\\) A crossing occurs if: $$ x \\leq \\frac{l}{2} \\sin(\\theta) $$ Count crossings and estimate \u03c0 3. Visualization Draw horizontal lines spaced \\(d\\) units apart Plot each needle segment Highlight those that cross a line import matplotlib.pyplot as plt import numpy as np import math # Parameters L = 1.0 # Length of the needle d = 2.0 # Distance between lines N_values = [100, 500, 1000, 5000, 10000, 20000] # Number of needle drops for N in N_values: # Simulate needle drops hits = 0 x_coords = [] y_coords = [] angles = [] crosses_line = [] for _ in range(N): x = np.random.uniform(0, d) y = np.random.uniform(0, 50) theta = np.random.uniform(0, math.pi / 2) x_coords.append(x) y_coords.append(y) angles.append(theta) # Check if needle crosses a line if x + (L * math.sin(theta) / 2) >= d or x - (L * math.sin(theta) / 2) <= 0: hits += 1 crosses_line.append(True) else: crosses_line.append(False) # Estimate \u03c0 pi_est = (2 * L * N) / (d * hits) if hits > 0 else 0 # Plot needles plt.figure(figsize=(8, 6)) for i in range(N): x_end = x_coords[i] + L * math.cos(angles[i]) * (y_coords[i] / 50) y_end = y_coords[i] + L * math.sin(angles[i]) * (y_coords[i] / 50) color = 'r' if crosses_line[i] else 'k' alpha = 0.5 if crosses_line[i] else 0.1 plt.plot([x_coords[i], x_end], [y_coords[i], y_end], color=color, alpha=alpha) plt.title(f\"Buffon's Needle Simulation (N={N})\\nEstimated \u03c0 = {pi_est:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.ylim(0, 50) plt.xlim(0, 8) plt.show() # Convergence plot pi_estimates = [] for N in range(0, 20001, 500): hits = 0 for _ in range(N): x = np.random.uniform(0, d) theta = np.random.uniform(0, math.pi / 2) if x + (L * math.sin(theta) / 2) >= d or x - (L * math.sin(theta) / 2) <= 0: hits += 1 pi_est = (2 * L * N) / (d * hits) if hits > 0 else 0 pi_estimates.append(pi_est) plt.figure(figsize=(8, 6)) plt.plot(range(0, 20001, 500), pi_estimates, label=\"Estimated \u03c0\") plt.axhline(y=math.pi, color='g', linestyle='--', label=\"Actual \u03c0\") plt.title(\"Convergence of \u03c0 Estimation via Buffon's Needle\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() 4. Analysis Buffon\u2019s method is slower to converge than the circle method More sensitive to random variation (especially for small \\(N\\) ) Useful to demonstrate geometric probability in a physical context Comparison Table Method Conceptual Basis Convergence Speed Visualization Real-World Intuition Circle-based Geometric Area Fast Simple Like throwing darts Buffon\u2019s Needle Geometric Probability Slower More complex Like dropping matchsticks Summary Monte Carlo methods demonstrate how randomness can estimate mathematical constants. Both methods rely on probabilistic geometry and law of large numbers . Estimations converge to \u03c0 as number of trials increases. Key Formulas Circle Method: \\(\\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}}\\) Buffon\u2019s Needle: \\(\\pi \\approx \\frac{2lN}{dC}\\) Try More Increase sample sizes to compare convergence rates Simulate in 3D (volume vs. sphere) Vary needle length in Buffon\u2019s Needle References Monte Carlo Methods in Python \u2014 NumPy Docs Buffon\u2019s Needle \u2014 Wikipedia Geometry and Probability \u2014 D. Feller, An Introduction to Probability Theory Colab Colab Link","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One elegant and visual application is the estimation of \u03c0. By simulating random processes like dart throws or needle drops, we can connect geometry , probability , and numerical methods into a hands-on approach that deepens our understanding of how randomness can be harnessed to estimate complex values like \u03c0.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"PART 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We consider a unit circle (radius = 1) inscribed inside a square of side length 2. Area of the circle: \\(A_{\\text{circle}} = \\pi r^2 = \\pi\\) Area of the square: \\(A_{\\text{square}} = (2r)^2 = 4\\) Now, randomly generate points inside the square. The probability that a point falls inside the circle is proportional to the area: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] So, we estimate \u03c0 as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-steps","text":"Generate \\(N\\) random points \\((x, y)\\) in the square \\([0, 1] \\times [0, 1]\\) Count how many satisfy: \\(x^2 + y^2 \\leq 1\\) Estimate \u03c0 using the formula above","title":"2. Simulation Steps"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Plot all generated points Use blue for points inside the circle Use red for points outside This visualizes how the proportion relates to \u03c0.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"As \\(N\\) increases: The estimate becomes more accurate. The error decreases proportionally to \\(1/\\sqrt{N}\\) . Plotting \u03c0 estimates against number of points shows convergence.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"PART 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon's Needle is a classic probability experiment: A floor is marked with parallel lines a distance \\(d\\) apart. A needle of length \\(l \\leq d\\) is dropped randomly. We calculate the probability \\(P\\) that the needle crosses a line. The probability of crossing is: \\[ P = \\frac{2l}{\\pi d} \\] Rearranging gives an estimator for \u03c0: \\[ \\pi \\approx \\frac{2lN}{dC} \\] Where: \\(N\\) = number of needle drops \\(C\\) = number of times the needle crosses a line","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-steps_1","text":"Drop \\(N\\) needles: Random center position from line: \\(x \\in [0, d/2]\\) Random angle: \\(\\theta \\in [0, \\pi/2]\\) A crossing occurs if: $$ x \\leq \\frac{l}{2} \\sin(\\theta) $$ Count crossings and estimate \u03c0","title":"2. Simulation Steps"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Draw horizontal lines spaced \\(d\\) units apart Plot each needle segment Highlight those that cross a line import matplotlib.pyplot as plt import numpy as np import math # Parameters L = 1.0 # Length of the needle d = 2.0 # Distance between lines N_values = [100, 500, 1000, 5000, 10000, 20000] # Number of needle drops for N in N_values: # Simulate needle drops hits = 0 x_coords = [] y_coords = [] angles = [] crosses_line = [] for _ in range(N): x = np.random.uniform(0, d) y = np.random.uniform(0, 50) theta = np.random.uniform(0, math.pi / 2) x_coords.append(x) y_coords.append(y) angles.append(theta) # Check if needle crosses a line if x + (L * math.sin(theta) / 2) >= d or x - (L * math.sin(theta) / 2) <= 0: hits += 1 crosses_line.append(True) else: crosses_line.append(False) # Estimate \u03c0 pi_est = (2 * L * N) / (d * hits) if hits > 0 else 0 # Plot needles plt.figure(figsize=(8, 6)) for i in range(N): x_end = x_coords[i] + L * math.cos(angles[i]) * (y_coords[i] / 50) y_end = y_coords[i] + L * math.sin(angles[i]) * (y_coords[i] / 50) color = 'r' if crosses_line[i] else 'k' alpha = 0.5 if crosses_line[i] else 0.1 plt.plot([x_coords[i], x_end], [y_coords[i], y_end], color=color, alpha=alpha) plt.title(f\"Buffon's Needle Simulation (N={N})\\nEstimated \u03c0 = {pi_est:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.ylim(0, 50) plt.xlim(0, 8) plt.show() # Convergence plot pi_estimates = [] for N in range(0, 20001, 500): hits = 0 for _ in range(N): x = np.random.uniform(0, d) theta = np.random.uniform(0, math.pi / 2) if x + (L * math.sin(theta) / 2) >= d or x - (L * math.sin(theta) / 2) <= 0: hits += 1 pi_est = (2 * L * N) / (d * hits) if hits > 0 else 0 pi_estimates.append(pi_est) plt.figure(figsize=(8, 6)) plt.plot(range(0, 20001, 500), pi_estimates, label=\"Estimated \u03c0\") plt.axhline(y=math.pi, color='g', linestyle='--', label=\"Actual \u03c0\") plt.title(\"Convergence of \u03c0 Estimation via Buffon's Needle\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show()","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Buffon\u2019s method is slower to converge than the circle method More sensitive to random variation (especially for small \\(N\\) ) Useful to demonstrate geometric probability in a physical context","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-table","text":"Method Conceptual Basis Convergence Speed Visualization Real-World Intuition Circle-based Geometric Area Fast Simple Like throwing darts Buffon\u2019s Needle Geometric Probability Slower More complex Like dropping matchsticks","title":"Comparison Table"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary","text":"Monte Carlo methods demonstrate how randomness can estimate mathematical constants. Both methods rely on probabilistic geometry and law of large numbers . Estimations converge to \u03c0 as number of trials increases.","title":"Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/#key-formulas","text":"Circle Method: \\(\\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}}\\) Buffon\u2019s Needle: \\(\\pi \\approx \\frac{2lN}{dC}\\)","title":"Key Formulas"},{"location":"1%20Physics/6%20Statistics/Problem_2/#try-more","text":"Increase sample sizes to compare convergence rates Simulate in 3D (volume vs. sphere) Vary needle length in Buffon\u2019s Needle","title":"Try More"},{"location":"1%20Physics/6%20Statistics/Problem_2/#references","text":"Monte Carlo Methods in Python \u2014 NumPy Docs Buffon\u2019s Needle \u2014 Wikipedia Geometry and Probability \u2014 D. Feller, An Introduction to Probability Theory","title":"References"},{"location":"1%20Physics/6%20Statistics/Problem_2/#colab","text":"Colab Link","title":"Colab"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}